# 操作系统学习笔记

[toc]

操作系统的学习离不开对于操作系统发展历史的了解， 其发展的历史是解决计算机使用中遇到问题的合集，即现代操作系统的功能合集便是操作系统所需要完成的功能的合集

现代操作系统主要需要完成的任务包含以下内容：
* 硬件适配：当计算机只有一台的时候，程序员只需要对这台计算机进行编程，其硬件也只有当前这台计算机及其配件，但是随着计算机的不断增加，其面临的硬件适配工作就变得繁杂了，为了防止程序员与底层硬件打交道（及其丑陋的硬件api）所以操作系统必须承担封装底层硬件接口的功能。
* 进程管理：早期的计算机通过人工放置纸带的方式加载程序与数据，程序执行完成后通过纸带进行输出，其进程管理完全由人工完成，但是随着计算机执行速度的加快，人工管理进程（即程序的执行）就变得不那么可行了，这必须由操作系统完成。
* 内存管理：既然管理了进程那当然要管理内存，随着进程管理的实现，计算机能够快速运行多道程序，每个进程只能访问自己的内存空间。
* 文件系统：前面提到了纸带加载程序，既然程序不再通过纸带加载，自然需要更好的程序保存方式。

以上简单的提及了，计算机操作系统发展过程中需要解决的需求作为本笔记的引言。


## 参考材料
* 《现代操作系统》
* 清华大学-陈渝-操作系统视频课
* Crash Course 计算机科学速成课

## 基础知识

### 操作系统的启动过程

1. BIOS运行：计算机启动后BIOS最先运行；
2. 硬件检查：BIOS会先检查各类设备是否被安装且是否能够正常响应；
3. 查找启动设备：BIOS通过读取用户事先配置的设备清单寻找相应启动设备，例如U盘，硬盘，软盘等；
4. 操作系统获取配置信息：操作系统再被引导启动后将通过载入设备驱动接过硬件的控制；


### 中断，异常，系统调用


## 进程

> 进程是操作系统中最核心的概念，其他所有的内容都是围绕着进程概念展开的。

在多道程序设计的系统上cpu通常快速的在多个进程间进行切换。再同一时刻一个cpu核心只运行一个进程，这是一种并行的错觉，可以称为伪并行。

### 进程模型

进程中包含执行一个程序所需要的所有资源，包括：
* 相关线程
* 被分配到的内存空间
* 其他运行程序所需要的资源（程序计数器，堆栈指针，打开文件清单，突出的报警，有关进程清单）

#### 进程控制块

##### 进程标识信息

##### 处理机状态信息保存区

* 用户可见寄存器
* 控制和状态寄存器
* 栈指针

##### 进程控制信息

* 调度和状态信息
* 进程间通信信息
* 存储管理信息
* 进程所用资源
* 有关数据结构连接信息


#### 进程的层次结构

* UNIX中父进程与其所有的子进程组成一个进程组，整个系统都属于一个根为init的进程树；
* Windows中没有层次的概念，所有进程的地位都是相同的，父进程会有一个可以控制子进程的令牌（句柄），但是可以将令牌送于其他进程；

### 进程的状态

进程有三种状态：
* 运行态 running
* 就绪态 ready
* 阻塞态 blocked

当进程无法继续运行下去的时候就会被阻塞。
运行和就绪之间由进程调度引起，二者没有本质区别只是就绪态暂时没有分配到cpu时间而已。
当阻塞态等待的外部实际发生时则会转为就绪态，待到cpu空闲并且轮到它运行则会转为运行态。

#### 创建进程

> 在简单的系统中（例如：微波炉或者其他单片机系统）系统启动时所有进程便都已经存在，但是在较为复杂的通用系统中，进程根据需要进行创建和撤销。

有4种主要事件导致进程的创建：
* 系统初始化。
* 执行了正在运行的进程所调用的进程创建系统调用。
* 用户请求创建一个新进程。
* 一个批处理作业的初始化。

几乎所有的进程都由现已存在的进程执行创建新建进程的系统调用而创建。

* UNIX：使用fork，execve两个系统调用，完成复制当前进程和修改为新进程的进程创建工作；
* Windows：使用Win32函数CreateProcess完成进程的创建和装载；

#### 进程的终止

进程的终止通常由下列条件引起：

* 正常退出（自愿的）：进程的工作完成通过调用exit（UNIX）或者ExitProcess（Windows）进行终止
* 出错退出（自愿的）。
* 严重错误（非自愿）。
* 被其他进程杀死（非自愿）：通常被某个进程调用kill（UNIX）或者TerminateProcess（Windows）杀死。在UNIX和Windows中杀死进程其创建的进程并不会被一并杀死。

#### 状态队列

#### 进程挂起

##### 就绪挂起

##### 阻塞挂起

### 进程的实现

操作系统维护着一张进程表， 进程由运行态转换到就绪或者阻塞态时需要保存相关信息，以便再次运行时调取。

#### 多道程序设计模型

### 线程的使用

在不使用线程的情况下如果需要实现复杂的交互程序，例如：在文件自动备份时输入文本或者在文件修改后想要即时查看到格式的重排，就需要中断当前的io操作，或者等待当前的io操作完成，因为使用了两个或者多个进程，而他们无法同时对同一文件进行操作。这就是为什么要引入与进程相似但是可以共享内存及其他资源的线程。即在复杂的交互程序中，多线程可以防止大量引入中断驱动程序设计模型

考虑是否使用多线程模式考虑安全问题，某一线程出问题会影响整个进程

线程的创建相较进程快很多（10-100倍）

> 假设通过进程中的单个线程进行非阻塞（异步）的磁盘操作，当接收到操作请求并进行系统调用时，该线程转而去执行其他任务直至先前的磁盘操作完成并且被再此安排给该线程进行后续操作

我们可以在进程中通过单个线程以显式保存计算状态的方式模拟线程及其堆栈，每个计算都有一个被保存的状态，这种设计被称为有限状态机。

* [多线程] 在进程中使用线程，使用阻塞调用：程序设计简单，且改善性能；
* [单线程] 在进程中不使用线程，使用阻塞调用：程序设计简单，但是性能拉跨；
* [有限状态机] 在进程中不使用线程，但是运用非阻塞调用和中断：程序设计复杂了，但是实现了高性能（比用线程阻塞调用更好）；

有限状态机更加适合有大量输入输出的情况。

#### 经典的线程模型

进程包含执行一个程序所需的所有资源（程序正文，数据以及其他资源的空间地址）。
进程拥有一个执行线程，这个线程是cpu调度执行的实体，而进程是程序资源的集合。

同一进程内的多个线程共享地址空间，全局变量，文件集，子进程，报警以及相关信号等，它们彼此间相互合作，而非进程间相互敌对的状态。

线程拥有自己独立的堆栈，计数器，寄存器，状态，这并不一样并不能互相访问，因为他们有各自需要执行的内容。

多线程的情况下进程通常从单个线程开始，该线程具有通过调用thread_create创建新线程的能力，并且当一个线程完成工作之后可以通过调用thread_exit退出。

线程也可以通过调用thread_join，实现等待一个特定线程退出。

线程可以通过调用thread_yield从而在一段时间内让出cpu，从而让其他的线程运行。

#### POSIX线程

POSIX定义了线程的标准，定义的线程包叫做Pthread。

#### 线程的实现

有两种主要的方法实现线程包：
* 用户空间中：通过函数库实现线程，可以在不支持线程的操作系统上实现，内核对线程的操作一无所知，就好像在管理单线程进程；
* 内核中：通过系统调用创建线程，由内核管理线程的状态。

两种方法各有利弊，也可以混合实现。

##### 在用户空间中实现线程

用户级线程需要很多非阻塞的系统调用，部分情况下需要调整操作系统的代码。

##### 内核中实现线程

内核线程没有非阻塞系统调用的需求。

##### 混合实现

两种线程实现方式结合使用。

#### 调度程序激活机制

这是一种改良线程的方法。
通过模拟内核线程的功能为用户级线程提供更好性能和灵活性。

#### 弹出式线程

当处理消息到达时导致系统创建对其处理的新线程称为弹出式线程。

弹出式线程通常在内核空间中使用，且如果内核线程出错造成的损害会大于用户空间线程。

#### 使单线程代码多线程化

### 进程通信

* 进程如何传递消息给另一进程
* 如何确保两个或多个进程在关键活动中不会出现交叉
* 如果与顺序有关联的话，如何保证进程执行的顺序

以上问题的后两个同样也适用于线程。

#### 竞争条件

#### 临界区

#### 忙等待的互斥

以下的解法本质上都是在进程想要进入临界区时，先检查是否允许进入，若不允许则原地等待，直到允许进入位置。

即临界区忙则申请进程等待

缺点：
* 浪费cpu时间
* 无法实现优先级调度

实现忙等待互斥的几种方法：
* 屏蔽中断：每个进程进入临界区后立即屏蔽所有中断，当进程离开则重新打开中断，这个方案非常不好，但是当进入临界区的操作十分简短时不失为一个好办法。
* 锁变量：使用一个变量记录当前临界区中是否已经有某个进程进入了，如果有则等待当前进程退出，但这样这个变量同样是一个共享的内存空间，在解决问题的同时创造了新的问题。
* 严格轮换法：通过变量在两个值之间不停的轮换，使两个进程轮流进入临界区。但是这样两个进程相互耦合，如果其中一个进程因为临界区外的其他原因阻塞，则另一个进程也会被迫等待。
* peterson解法：在锁变量的基础上增加了修改后的一个while检查，从而使得重写丢失后也不会出现两个进程同时进入临界区的情况。

```c
// peterson 解法

#define FALSE 0
#define TRUE 1
#define N 2

int turn;
int interested[N];

void enter_region(int process);
{
    int other;
    other = 1 - process; // 这里只是表示这是另一个进程
    interested[process] = TRUE; // 表示对临界区感兴趣 
    turn = process; // 表示下一个进入的进程

    /*
        当两个进程同时争夺时，turn为后一个写入process的进程
        则第一个进程因为turn != process 直接进入临界区
        而第二个进程则在while循环
        直到第一个进程退出将第二个进程视角的interested[other] 置为 FALSE
    */
    while(turn == process && interested[other] == TRUE);
}

void leave_region(int process);
{
    interested[process] = FALSE;
}
```

* TSL(Test and Set Lock)或者XCHG：一种硬件支持的方案。

> 忙等待的锁通常称为自旋锁(spin lock)

#### 睡眠与唤醒

> 生产者消费者问题

当消费者取出为0的队列值，随后被调度暂停。生产者添加队列数据，并且发现原队列值为0，对消费者进行唤醒。但由于当前消费者并未睡眠所以信号丢失，当调度再次运行到消费者由于先前取出的队列值为0，消费者进行睡眠。随着队列被填满，生产者进入睡眠，则两个进程全部进入了睡眠状态。

通过标志位在当前进程未睡眠时记录唤醒的信号，称为唤醒等待位，当进程睡眠时，如果唤醒等待位存在唤醒信号则不进入睡眠。

但是以上方法并不能从根本上解决这个问题。

#### 信号量

信号量通过一个整数变量来统计和消耗唤醒次数

对信号量操作时通常需要屏蔽中断，或者通过TSL或者XCHG指令来防止多个CPU同时对信号量进行修改。由于对信号量操作的时间十分简短，所以这通常不会对系统产生副作用。

其中的down操作可以对信号量-1，up操作可以对信号量+1。如果当前信号量为0则暂停down操作且将执行down操作的进程睡眠。直到当前访问共享变量的进程对信号量执行up操作时系统调度选择任意睡眠进行唤醒并继续其down操作。

#### 互斥量

互斥量是信号量的一个简化版本，通常用于不需要计数的场景。

互斥量可以容易的在用户空间中实现。可以用于线程同步等操作。

#### 管程

#### 消息传递

#### 屏障

### 调度

#### 批处理系统中的调度

#### 交互式系统中的调度

#### 实时系统中的调度

### 经典的IPC问题

#### 哲学家就餐问题

#### 读者-写者问题

### 有关进程和线程的研究

## 内存管理

### 分层

* 寄存器
* 高速缓存
* 主存（内存）
* 存储（外存）

### 连续内存分配

#### 分配方式

* 最优适配分配
* 最差适配分配
* 第一匹配分配

#### 碎片整理

### 非连续内存分配

#### 分段

#### 分页

* 快表（TLB，缓存最近访问的页帧转换表项）
* 二级，多级页表（类似树）
* 反向页表（高级cpu才能实现）

### 虚拟内存

* 覆盖技术（程序开发难度大）
* 交换技术（操作系统开销大）
* 虚存技术

#### todo：是否有基于段式的虚拟内存管理方法

#### 基于页式内存管理实现虚拟内存

程序需要具有局部性（更好的程序可以让操作系统方便进行虚存管理）
* 时间局部性
* 空间局部性

##### 页表表项

* 驻留位
* 保护位
* 修改位
* 访问位

##### 缺页中断

##### 局部页面置换算法
* 最优页面置换算法（无法实现，但可以作为评价标准）
* 先进先出算法（FIFO，效果平平）
* 最近最久未使用算法（LRU，代价太大）
* 时钟页面置换算法（结合了LRU和FIFO的优点）
    * 二次机会法（添加了对写入操作的考虑）
    * 最不常用法

##### belady现象


##### 全局页面置换算法
工作集（进程当前正在使用的逻辑页面的集合，包括当前在内存和不在内存中的）
常驻集（当前时刻进程实际驻留在内存当中的页面集合）

* 工作集页面置换算法
* 缺页率页面置换算法（基于缺页率改变常驻集的大小）

##### 抖动问题

### 地址空间

## 文件系统

## 硬件适配

书上提及read 与 write 两个命令来说明硬件接口的丑陋，其每个接口平均都需要13个参数实现相应功能，对程序的编写过程极为不便，通过操作系统对硬件接口的封装，程序编写可以使用更加抽象而简单的方式进行处理硬件操作。

### 硬件介绍

## 历史