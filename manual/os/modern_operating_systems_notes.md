# 操作系统知识笔记

参考书籍:

* 现代操作系统
* [理解linux进程](https://github.com/tobegit3hub/understand_linux_process)
* [操作系统思考](https://github.com/wizardforcel/think-os-zh)
* [鸟哥的linux私房菜](http://cn.linux.vbird.org/linux_basic/linux_basic.php)

## 概述

操作系统是一个将复杂硬件操作抽象的表达形式, 这样我们不需要关心过多的硬件操作细节, 这一思想也被用于在用户层面构建的其他工具系统, 这使得用户和其他程序员不需要了解具体细节便能够使用更加复杂的系统

* 图形用户界面(GUI)实际上不是操作系统的一部分  
* 计算机的运行状态分为内核态(管态, 核心态), 用户态

### CPU

* 每个处理器都有一套专门的指令集, 根据不同指令集开发的程序, 无法在非对应的CPU上运行
* 通用寄存器: 用于存放变量和临时结果
* 程序计数器: 保存将要取出的下一条指令的内存地址, 当命令取出之后就会更新为指向后继指令的内存地址
* 堆栈指针: 指向内存中当前栈的顶端
* 程序状态字寄存器(PSW): - TODO
* 在时间多路复用(time multiplexing)CPU中, 操作系统经常会中止某些正在运行的程序并启动另外一个程序, 每次停止运行一个程序时, 操作系统就必须保存所有的寄存器, 稍后这个程序再被启动时, 就可以将寄存器重新装入

* 流水线(pipeline): 当一条指令被取入流水线当中, 它就必须被执行完毕
* 流水线造成了机器实现软件的复杂性问题
* 超标量CPU: 有多个执行单元, 可以使程序不需要按顺序执行
* TRAP: 可以将用户态切换到内核态
* 多线程, 多核芯片 - TODO

#### 指令集

* 精简指令集

    > 较为精简, 每个指令集执行时间较短, 完成动作单纯, 执行效能较好, 完成复杂操作需要多个指令来完成, 现在的典型代表是arm系列

* 复杂指令集

    > 指令数目多且复杂, 指令长短不一, 执行时间较长, 但是可以处理的工作较为丰富, 典型代表是amd, intel的x86架构

### 存储器

* 存储器系统中的顶层是寄存器, 可以有软件决定如何使用
* 存储器系统第二层是高速缓存, 多数由硬件控制
* 主存被分割为高速缓存行(cache line), CPU所需高速缓存行是否在高速缓存中, 如果在则命中, 无需访问内存, 否则访问内存

## 操作系统相关知识

### 进程

* 进程本质上就是正在执行的一个程序, 基本是容纳运行一个程序所需的所有信息的容器
* 与每个进程相关的是进程的地址空间
* 进程树 - TODO
* 系统管理器授权每个进程使用一个给定的UID(User IDentification)标识
* 每个被启动的进程都有一个启动该进程的用户UID
* 子进程拥有与父进程一样的UID
* 用户可能是某个组的成员, 每个组也有一个GID(Group IDentification)标识

### 程序运行的过程

当程序启动时操作系统会以如下操作来进行

1. 操作系统创建新的进程
2. 加载器从磁盘拉取代码文本到主存, 并且从入口函数开始运行
3. 运行过程中cpu以 取指(fetch), 译码(decode), 执行(execute) 的指令周期运行进程

* fetch: 从内存中获取下一条指令, 并且存在指令寄存器中
* decode: cpu中的控制单元将指令进行译码, 并将命令发送到其他单元
* execute: 根据控制单元的信号执行合适的计算

指令集:

* 加载: 将内存值送到寄存器
* 算术/逻辑: 从寄存器加载操作数, 执行运算, 将结果存到寄存器
* 存储: 将寄存器中的值送到内存
* 跳转/分支: 修改程序计数器, 使控制流跳到程序的另一个位置

### 内存瓶颈

### 进程的相关知识

#### PID & PPID

pid是用于标识和区分进程的id, 非0正整数, 其中linux pid为1是init进程, 在整个系统运行过程中都会存在

ppid 是父进程的id, linux中(除去init进程以外)所有进程都是由已经存在的进程(父进程)调用fork接口产生的, 而init则是所有进程的源头

#### 进程状态

linux 中包含7种进程状态:

* 运行 R running
* 睡眠 S sleeping
* 不可中断睡眠 D disk sleep
* 停止 T stopped
* 跟踪停止 t tracing stop
* 死亡 X dead
* 僵尸 Z zombie

shell 中使用ps aux 显示的进程状态与上面不同, 如下所示:

* O 正在运行
* S sleeping
* R runable or running
* I idle
* Z zombie
* T traced
* B 进程等待内存页
* D 不可中断睡眠
* N nice 低优先级任务
* s 进程是会话期首进程
* \+ 进程属于前台进程组
* | 进程是多线程的
* < 高优先级任务

##### 死锁

两个进程都想要请求对方的资源, 且都不释放自己所占有的资源

##### 活锁

两个进程同时请求同一个资源却又都让出资源, 资源即不被占用, 两个进程也无法继续运行

##### 饿死

等待资源的进程被后来的进程不断的优先使用无法占用资源

#### 退出码

进程退出时会返回0-255整数的退出码, 0为正常

#### 文件锁

#### 进程类型

* 孤儿进程: 失去父进程的进程, 这样的进程一般可以被托管给pid为1的init进程, 进而成为守护进程
* 僵尸进程: 当进程运行结束, 父进程却没有使用wait或者waitpid调用获取该进程的进程状态, 使得系统一直保存有该进程的进程描述
* 守护进程: 长时间运行的进程, 且不受部分终端信号影响的进程, 可通过 nohup 实现

### 进程间通信 (Inter Process Communication, IPC)

* 管道 pipe
* 信号 signal
* 内核消息队列 message
* 共享内存 shared memory
* 信号量 semaphore
* 套接口 socket

三个问题:

1. 进程间如何通信
2. 确保进程间的关键活动不会出现交叉
3. 进程间的顺序

解决第一个问题可以通过共享的内存和文件即临界区, 进而引入第二个问题, 以解决临界区的安全

Peterson解法, 给予了一个得以解决第二个问题的方法
该方法可简单描述为: 当两个进程同时访问临界区时, 首先调用enter_region方法(即使同时调用也只有一个进程可以立即返回且对临界区进行操作, 另一个进入循环忙等待), 当成功访问临界区的进程访问结束后调用leave_region, 从而将循环忙等待指令的另一进程放行至临界区

访问 -> 忙等待 -> 放行

Peterson解法在运行具有调度优先级时会出现低调度等级的进程无法离开临界区, 从而阻塞高调度等级进程锁死临界区的情况

### 多任务

#### 中断

中断发生的过程:

1. 中断发生时, 硬件将程序计数器保存到特殊寄存器中, 并且跳转到合适的中断处理器
2. 中断处理器将程序计数器和位寄存器, 以及任何打算使用的数据寄存器的内容储存到内存中
3. 中断处理器运行处理中断所需的代码
4. 之后复原所保存寄存器的内容, 最后复原被中断进程的程序计数器, 跳回被中断进程

#### 上下文切换

### 内存

#### 地址空间

* 从某个最小值存储位置到最大值存储位置的列表, 在地址空间中进程可以进出读写, 地址空间中存放有可执行程序, 程序的数据以及程序的堆栈...

#### 内存段

一个运行中的进程数据组织分为4个段:

* text 程序文本, 程序所组成的机器语言指令(即程序的本体)
* static 包含由编译器分配变量
* stack 栈 由栈帧组成, 每个栈帧包含函数参数, 本地变量和其他
* heap 堆 java, c# 等面向对象语言中的的对象所在的内存块, c当中需要使用malloc来分配

内存段的组织方式是由编译器和操作系统共同决定的, 不同的操作系统中细节略有不同, 以下是共同点:

* text段靠近内存的底部, 接近0的地址
* static段通常刚好在text段上面
* stack段靠近内存的顶部, 从高地址向低地址方向增长
* heap段通常在static段的上方, 向高地址方向增长

```text
高地址
栈段      
栈增长方向  
...       
堆增长方向
堆段      
静态段     
程序      
低地址
```

#### 地址翻译

将虚拟地址翻译为物理地址

#### 内存错误

以下的行为会被认为是内存错误:

* 未分配内存
* 释放后访问
* 释放未分配的内存
* 重复释放内存
* 向已经释放或未申请的地址设置指针

#### 内存泄漏

### 线程

操作系统创建进程时, 同时也会创建执行线程, 所以一个程序必然包含一个线程

单线程进程, 我们称之为在同一地址空间内, 只运行一个执行线程
多线程进程, 则是在同一地址空间中,拥有多个运行中的线程

由于程序代码在text段中, 线程运行相同的代码, 所以他们共享text段, 同样还有static段, 和堆区, 但是每个线程都有自己栈, 所以每个线程调用方法不会互相影响

#### 线程同步

每次运行程序的时候, 线程不会在同一时间点上中断, 且调度器可能选择不同的线程来运行, 所以线程运行的时间序列和结果都是不同的

### 文件

* 大多数操作系统支持目录(directory)的概念, 从而可以将文件分类为组
* 目录层结构中的每一个文件都可以通过从目录顶部, 即根目录(root directory)开始的路径名(path name)来确定

### 输入/输出

### 保护

### shell

* shell 不是操作系统的组成部分

## 一些实例

### POSIX

#### 进程管理

| 调用                                    | 说明                     |
| --------------------------------------- | ------------------------ |
| `pid = fork()`                          | 创建与父进程相同的子进程 |
| `pid = waitpid(pid, &statloc, options)` | 等待一个子进程终止       |
| `s = execve(name, argv, environp)`      | 替代一个子进程的核型映像 |
| `exit(status)`                          | 终止进程执行并返回状态   |

#### 文件管理

| 调用                                   | 说明                         |
| -------------------------------------- | ---------------------------- |
| `fd = open(file, how, ...)`            | 打开一个文件供读, 写或两者   |
| `s = close(fd)`                        | 关闭一个打开的文件           |
| `n = read(fd, buffer, nbytes)`         | 把数据从一个文件读到缓冲区中 |
| `n = write(fd, buffer, nbytes)`        | 把数据从缓冲区写到一个文件中 |
| `position = lseek(fd, offset, whence)` | 移动文件指针                 |
| `s = stat(name, &buf)`                 | 获取文件状态信息             |

#### 目录和文件系统管理

| 调用                             | 说明                               |
| -------------------------------- | ---------------------------------- |
| `s = mkdir(name, mode)`          | 创建一个新目录                     |
| `s = rmdir(name)`                | 删去一个空目录                     |
| `s = link(name1, name2)`         | 创建一个新目录项name2, 并指向name1 |
| `s = unlink(name)`               | 删去一个目录项                     |
| `s = mount(special, name, flag)` | 安装一个文件系统                   |
| `s = umount(special)`            | 卸载一个文件系统                   |

#### 杂项

| 调用                       | 说明                               |
| -------------------------- | ---------------------------------- |
| `s = chdir(dir name)`      | 改变工作目录                       |
| `s = chmod(name, mode)`    | 修改一个文件的保护位               |
| `s = kill(pid, signal)`    | 发送信号给一个进程                 |
| `seconds = time(&seconds)` | 自1970年1月1日起的流逝时间(时间戳) |

### read系统

#### 一些需要记住的事情

* 单核且单CPU计算机 一次只能执行一条指令

> 一个进程正在用户态中运行一个用户进程, 并且需要一个系统服务, 比如文件读取那么它就必须执行一个TRAP或者系统调用指令, 将控制转移到操作系统. 操作系统接着通过参数检查找出所需要调用进程, 然后执行系统调用, 并把控制返回给在系统调用后面更随着的指令, 某种意义上系统调用像是在进行一次特殊的过程调用,但是系统调用可以进入内核, 而过程调用则不能
