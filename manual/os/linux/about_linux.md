# GNU/Linux 漫游指南

[toc]

## 内核

### 版本

## 发行版

### 演变

### 比较

## Linux 启动

### IDE，SATA，AHCI

IDE 是一种并行接口
SATA 是串行接口

早期硬盘为 SATA 接口， 后发展为 IDE， 但是 IDE 由于将数据分开并行传输数据容易出现丢失或者干扰， 后来主流又改为 SATA 串口， 随着 SATA 的发展 SATA3.0 传输带宽也达到了 6Gpbs

AHCI 是一种提高 SATA 硬盘读写效率的协议

SCSI 硬盘，包含完全独立的高速 SCSI 卡来进行读写操作

### 插槽与目录名

IDE 磁盘目录名与插槽相关
| IDE\Jumper      | Master     | Slave      |
| --------------- | ---------- | ---------- |
| IDE1(Primary)   | `/dev/hda` | `/dev/hdb` |
| IDE2(Secondary) | `/dev/hdc` | `/dev/hdd` |

SATA 磁盘/U 盘/其他 SCSI 磁盘的目录名与检测顺序相关, 与插槽代号无关, 其格式为 `/dev/sd[a-p]`

### 磁盘划分

-   MBR (Master Boot Record): 主引导记录, 用于安装启动管理程序, `446bytes`
-   partition table: 分区表, 用于记录整个磁盘分区状态, `64bytes`

关于主引导记录:

1. `boot loader` 是安装在 MBR 上读取核心内容运行的软件
2. `boot loader` 可以将启动管理功能转交给其他分区内的 `loader`
3. 其他分区内的 `loader` 安装在各自分区的 `启动磁区(boot sector)` 中

关于分区:

1. 对分区表的配置就是对磁盘进行分区
2. 分区表只能记录 4 条分区记录, `主要(Primary)` 或 `扩展(Extended)`, 注意: `主要分区 + 扩展分区 = 4`, 且 `扩展分区` 做多只能有 1 个
3. 分区的最小单位是 `柱面(cylinder)`
4. 系统必须参考分区表才能对分区进行数据处理

> 扩展分区并非实际的分区, 只存储一个扩展分区的分区数据, 其中包含若干个逻辑分区的信息

关于 `逻辑分区(logical partition)`:

1. 通过利用扩展分配可以增加逻辑分区
2. IDE 中最多 59 个逻辑分区(5-63), SATA 中最多 11 个逻辑分区(5-15)

### 分区与挂载

### 分区

### 启动

1. 上电加载 BIOS 信息， 自检， 依照 BIOS 设定找到第一个启动设备（硬盘或者设置的光驱或者 U 盘）
2. 读取启动设备的 MBR， 加载 MBR 的 boot loader （例如 grub）
3. 根据 bootloader 的设置加载内核， 内核再次进行系统检测， 检测的同时会加载硬件驱动
4. 启动第一个进程/sbin/init
5. init 调用配置文件对系统进行初始化
   ...

at last. 最后启动字符界面 或者如果有图形界面则会启动图形界面

简化一点:
bios 自检 -> 启动 grub -> 加载内核 -> 执行第一个进程 -> 配置系统初始化环境

#### BIOS

-   POST (Power On Self Test) 对硬件及外围设备进行第一次自检
-   在自检没有问题的情况下 对硬件进行初始化， 根据当前可启动设备的顺序选择设备进行开机启动
-   当选择的设备启动后， 从该设备的 MBR 中读取 BootLoader (启动引导程序) (例如 GRUB)引导操作系统启动。

当 MBR 加载到 RAM 中后 BIOS 会将控制权交给 MBR

#### UEFI 与 GPT & Legacy 与 MBR

uefi 和 legacy 是 bios 的不同启动模式， uefi 增加了软硬件交互的统一标准

uefi 的优势：

-   接口协议化，硬件驱动的编写和设置更加容易
-   支持了 gpt 分区格式
-   增加了安全功能
-   支持更多启动设备

Legacy 通常使用 MBR 分区进行引导
UEFI 通常使用 GPT 分区进行引导 UEFI 只支持 64 位机器

MBR 和 GPT 只是一种分区方式

由于 MBR 无法支持 2TB 以上硬盘， 所以当硬盘大于 2TB 时仅可以选择 GPT
MBR 用于大于 2TB 硬盘时超过 2TB 的部分无法识别和使用

#### GRUB

GRUB 是 GNU 的多重操作系统启动管理器， 用于引导不同的系统启动

## shell脚本

shell 是操作内核的门户， 用户命令通由 shell 送入内核执行

```shell
#!/bin/bash
# 注释
echo "helloworld"
```

-   `#!`: 定义脚本执行的解释器
-   `#`: 注释, 注释以 `#` 开头, 由于没有多行注释, 所以每一行都需要添加 `#`
-   `echo`:

### 变量

命名规则:

-   必须以英文字母开头
-   只能使用数字, 字母, 下划线
-   不能使用 bash 关键字

```bash
# 定义时注意等号不留空格
variable=value
```

定义变量时不加 `$`

#### 使用变量

使用变量时需要加 `$`

```bash
echo $variable

echo ${variable}

# 使用${}用于帮助解释器识别边界 (tips: 这种写法和js具有一致性,方便记忆)
echo "use ${variable}format like this"
```

#### 变量类型

-   局部变量: 定义在脚本或命令中, 只在当前 shell 实例中有效, 无法被其他 shell 实例访问
-   环境变量: 所有程序都能够访问
-   shell 变量: shell 程序的特殊变量

#### 特殊变量(shell 变量)

| 变量 | 含义                                                               |
| ---- | ------------------------------------------------------------------ |
| `$0` | 当前脚本的文件名                                                   |
| `$n` | 传递给脚本的参数, `$1`: 是第一个参数, `$2`: 是第二个参数, 依此类推 |
| `$#` | 获取传递参数的个数                                                 |
| `$*` | 获取传递的所有参数                                                 |
| `$@` | 获取传递的所有参数, 参数中包含 `""`时, 与 `$*` 有差异              |
| `$?` | 上一条命令的推出状态, 由 `exit` 设置                               |
| `$$` | 当前 shell 脚本的进程 ID                                           |

##### `$*` 与 `$@`

##### 退出状态

### 输入&输出

#### printf

#### read

### 转义字符

使用 `echo` 输出时默认不转义字符, 添加 `-e` 选项对转义字符进行替换

tips: `echo` 有一个 `-E` 选项, 表示禁止使用转义字符, 这和正则表达式的大写转义符一样用于表示与小写相反的功能

### 命令替换

### 变量替换

### 运算符

#### 算术运算符

#### 关系运算符

#### 布尔运算符

#### 字符串运算符

#### 文件测试运算符

### 字符串

#### 字符串拼接

#### 获取字符串长度

#### 截取字符串

#### 查找字符串

### 数组

### 判断

#### if

#### case

### 循环

#### for

#### while

#### until

#### break

#### continue

### 函数

#### 定义函数

#### 参数

#### 获取返回值

### 输入输出重定向

### Here Document

### /dev/null

### shell 文件包含

### awk

### grep

### sed

## 文件系统

通过 `LVM` 或者 `软件磁盘阵列` 可以一个将一个分区格式化为多个文件系统, 或者将多个分区合成为一个文件系统, 所以我们通常将可挂载的数据称为一个 `可挂载的文件系统` 而不是分区

-   `superblock`: 记录所在文件系统的整体信息,包括 `inode` 与 `block`的总量, 使用量, 剩余量, 以及文件系统的相关格式等信息
-   `inode`: 记录文件的属性, 每个文件只占用一个 `inode`, 因此能够创建文件的数量与`inode` 的数量相关, 同时记录文件所在的 `block` 号码
-   `block`: 实际记录文件的内容, 一个文件可能会占用多个 `block`

关于 `data block`:

-   block 大小有 1k, 2k, 4k 并且在格式化时就已经固定
-   每个 block 只能存放一个文件的数据
-   如果数据量小于一个 block 的大小则多出的容量不能被其他文件所使用

关于 `inode`:

`inode` 所包含的文件数据有:

-   文件的存取模式(read/write/excute)
-   文件的拥有者和群组(owner/group)
-   文件的容量
-   文件的创建和改变的时间(ctime)
-   最近一次读取的时间(atime)
-   最近一次修改的时间(mtime)
-   定义文件特性的 flag
-   文件 block 内容的指向(pointer)

`inode` 的一些特性:

-   每个 `inode` 的大小固定为 `128bytes`
-   系统读取文件时需要先读取 `inode` 然后才能判断权限与用户是否符合, 并实际开始读取 `block` 中的文件内容

### 文件系统的类型

linux 常用的文件系统类型， 常见发行版现在多为ext3/4 且ext系都能向上挂载，可以方便的升级无需格式化
-   ext
-   ext2
-   ext3
-   ext4

unix 常用的文件系统类型

-   XFS
-   JFS
-   UFS

windows 常用的文件系统类型

-   FAT
-   NFS

### 类型

### 文件

绝对路径 & 相对路径
* 以根目录为起始的路径形式 为绝对路径
* 不以根目录为起始的路径形式 为相对路径

根据实际需求判断使用何种路径形式，以确保方便或者准确

touch

cat

cp

mv

rm

tar

find

### 目录

几个特殊的目录位置:
* `.` 当前目录
* `..` 上级目录
* `~` 当前用户的家目录
* `~[user]` 指定用户的家目录
* `-` 上次跳转之前的目录

pwd 显示当前目录


mkdir

rmdir

cd

ls

### 挂载

mount

unmount

## 用户

查看用户
`id [option]... [username]...`

```
[root@localhost ~]# id www
uid=500(www) gid=500(www) groups=500(www)
```

添加用户

useradd

添加组
groupadd


修改用户
usermod


passwd

userdel

#### 群组与用户

-   `/etc/passwd` 存放用户信息
-   `/etc/shadow` 存放密码
-   `/etc/group` 存放群组信息

### 账户与组

## 权限


### 文件权限

## 管理

## linux 根文件系统

```none
/
|-/bin -> /usr/bin
|-/boot
|-/dev
|-/etc
|-/home
|-/root
|-/run
|-/sbin -> /usr/sbin
|-/tmp
|-/usr
    |-/usr/bin
    |-/usr/local
    |-/usr/sbin
    |-/usr/tmp
|-/var
    |-/var/tmp -> /usr/tmp
```

### /bin

主要存放可执行文件
该目录下的命令可以被 root 与一般用户所使用, 由于这些命令在挂接其它文件系统之前就可以使用, 所以`/bin`目录必须和根文件系统在同一个分区中

### /boot

### /debootstrap

### /dev

因为在这个目录中包含了所有 Linux 系统中使用的外部设备

### /etc

该目录下存放着系统主要的配置文件, 例如人员的账号密码文件, 各种服务的其实文件等
一般来说, 此目录的各文件属性是可以让一般用户查阅的, 但是只有 root 有权限修改

### /home

系统默认的用户文件夹, 它是可选的, 对于每个普通用户, 在`/home`目录下都有一个以用户名命名的子目录, 里面存放用户相关的配置文件

### /lib

该目录下存放共享库和可加载(驱动程序), 共享库用于启动系统, 运行根文件系统中的可执行程序, 比如: `/bin`, `/sbin` 目录下的程序

### /lost+found

该目录是使用标准的 ext2/ext3 档案系统格式才会产生的一个目录, 目的在于当系统发生错误时, 将一些遗失的片段放置在这个目录下

该目录一般情况是空的, 只有 root 用户才能打开

lost+found 目录的文件通常是未链接的文件, 这些文件还被一些进程使用(数据没有删除)

### /media

软盘, 光盘, U 盘等等装置挂载位置

### /mnt

镜像,硬盘等

用于临时挂载某个文件系统的挂接点, 通常是空目录, 也可以在里面创建一引起空的子目录, 比如`/mnt/cdram`, `/mnt/hda1` 用来临时挂载光盘, 移动存储设备等

### /misc

其它各类挂载位置

### /opt

是一些大型软件的安装目录, 或者是一些服务程序的安装目录

### /proc

正在运行的内核信息映射

主要输出:

-   进程信息
-   内存资源信息
-   磁盘分区信息等等

这是一个空目录, 常作为 proc 文件系统的挂接点, proc 文件系统是个虚拟的文件系统, 它没有实际的存储设备, 里面的目录, 文件都是由内核
临时生成的, 用来表示系统的运行状态, 也可以操作其中的文件控制系统

### /root

root 的主文件夹, 即是根用户的目录, 与此对应, 普通用户的目录是`/home`下的某个子目录

### /run

里面的东西是系统运行时需要的, 不能随便删除, 但是重启的时候应该抛弃, 下次系统运行时重新生成

### /sbin

该目录下存放系统命令, 即只有 root 能够使用的命令, 系统命令还可以存放在`/usr/sbin`, `/usr/local/sbin`目录下, `/sbin`目录中存放的是基本的系统命令, 它们用于启动系统和修复系统等, 与`/bin`目录相似, 在挂接其他文件系统之前就可以使用`/sbin`, 所以`/sbin`目录必须和根文件系统在同一个分区中

### /srv

主要用来存储本机或本服务器提供的服务或数据(用户主动生产的数据, 对外提供服务)

### /sys

硬件设备的驱动程序信息

### /tmp

用于存放临时文件, 通常是空目录, 一些需要生成临时文件的程序用到的`/tmp`目录下, 所以`/tmp`目录必须存在并可以访问

### /usr

`Unix Software Resource` Unix 操作系统软件资源所放置的目录

### /var

主要针对常态性变动的文件, 包括缓存(cache), 日志(log file)以及某些软件运作所产生的文件

## 网络

## 附录

### 文件颜色

-   绿色: 可执行文件，可执行的程序
-   红色: 压缩文件或者包文件
-   蓝色: 目录
-   白色(灰色): 一般性文件, 如文本文件, 配置文件, 源码文件等
-   浅蓝色: 链接文件, 主要是使用 ln 命令建立的文件
-   黄色: 设备文件
-   红色闪烁(红底): 表示链接的文件有问题了
-   绿底色: 777

## 附录：GNU/Linux 常用软件
