# GNU/Linux 漫游指南

[toc]

## 内核

### 版本

## 发行版

### 演变

### 比较

## Linux 启动

### IDE，SATA，AHCI

IDE 是一种并行接口
SATA 是串行接口

早期硬盘为 SATA 接口， 后发展为 IDE， 但是 IDE 由于将数据分开并行传输数据容易出现丢失或者干扰， 后来主流又改为 SATA 串口， 随着 SATA 的发展 SATA3.0 传输带宽也达到了 6Gpbs

AHCI 是一种提高 SATA 硬盘读写效率的协议

SCSI 硬盘，包含完全独立的高速 SCSI 卡来进行读写操作

### 插槽与目录名

IDE 磁盘目录名与插槽相关
| IDE\Jumper      | Master     | Slave      |
| --------------- | ---------- | ---------- |
| IDE1(Primary)   | `/dev/hda` | `/dev/hdb` |
| IDE2(Secondary) | `/dev/hdc` | `/dev/hdd` |

SATA 磁盘/U 盘/其他 SCSI 磁盘的目录名与检测顺序相关, 与插槽代号无关, 其格式为 `/dev/sd[a-p]`

### 磁盘划分

- MBR (Master Boot Record): 主引导记录, 用于安装启动管理程序, `446bytes`
- partition table: 分区表, 用于记录整个磁盘分区状态, `64bytes`

关于主引导记录:

1. `boot loader` 是安装在 MBR 上读取核心内容运行的软件
2. `boot loader` 可以将启动管理功能转交给其他分区内的 `loader`
3. 其他分区内的 `loader` 安装在各自分区的 `启动磁区(boot sector)` 中

关于分区:

1. 对分区表的配置就是对磁盘进行分区
2. 分区表只能记录 4 条分区记录, `主要(Primary)` 或 `扩展(Extended)`, 注意: `主要分区 + 扩展分区 = 4`, 且 `扩展分区` 做多只能有 1 个
3. 分区的最小单位是 `柱面(cylinder)`
4. 系统必须参考分区表才能对分区进行数据处理

> 扩展分区并非实际的分区, 只存储一个扩展分区的分区数据, 其中包含若干个逻辑分区的信息

关于 `逻辑分区(logical partition)`:

1. 通过利用扩展分配可以增加逻辑分区
2. IDE 中最多 59 个逻辑分区(5-63), SATA 中最多 11 个逻辑分区(5-15)

### 分区与挂载

### 分区

### 启动

1. 上电加载 BIOS 信息， 自检， 依照 BIOS 设定找到第一个启动设备（硬盘或者设置的光驱或者 U 盘）
2. 读取启动设备的 MBR， 加载 MBR 的 boot loader （例如 grub）
3. 根据 bootloader 的设置加载内核， 内核再次进行系统检测， 检测的同时会加载硬件驱动
4. 启动第一个进程/sbin/init
5. init 调用配置文件对系统进行初始化
   ...

at last. 最后启动字符界面 或者如果有图形界面则会启动图形界面

简化一点:
bios 自检 -> 启动 grub -> 加载内核 -> 执行第一个进程 -> 配置系统初始化环境

#### BIOS

- POST (Power On Self Test) 对硬件及外围设备进行第一次自检
- 在自检没有问题的情况下 对硬件进行初始化， 根据当前可启动设备的顺序选择设备进行开机启动
- 当选择的设备启动后， 从该设备的 MBR 中读取 BootLoader (启动引导程序) (例如 GRUB)引导操作系统启动。

当 MBR 加载到 RAM 中后 BIOS 会将控制权交给 MBR

#### UEFI 与 GPT & Legacy 与 MBR

uefi 和 legacy 是 bios 的不同启动模式， uefi 增加了软硬件交互的统一标准

uefi 的优势：

- 接口协议化，硬件驱动的编写和设置更加容易
- 支持了 gpt 分区格式
- 增加了安全功能
- 支持更多启动设备

Legacy 通常使用 MBR 分区进行引导
UEFI 通常使用 GPT 分区进行引导 UEFI 只支持 64 位机器

MBR 和 GPT 只是一种分区方式

由于 MBR 无法支持 2TB 以上硬盘， 所以当硬盘大于 2TB 时仅可以选择 GPT
MBR 用于大于 2TB 硬盘时超过 2TB 的部分无法识别和使用

#### GRUB

GRUB（GRand Unified Bootloader）是一种用于在Linux操作系统中加载内核的软件。它允许用户在启动时从多种选项中选择要加载的内核。GRUB通常用于安装在磁盘上的Linux系统，但在某些嵌入式系统上，它也用于启动和配置嵌入式Linux系统。

GRUB还与其他加载器一起使用，如LILO、SystemRescueCD和U-Boot。这些加载器也用于在Linux操作系统中加载内核，但它们的功能和用法略有不同。

## shell脚本

shell 是操作内核的门户， 用户命令通由 shell 送入内核执行

```shell
#!/bin/bash
# 注释
echo "helloworld"
```

- `#!`: 定义脚本执行的解释器
- `#`: 注释, 注释以 `#` 开头, 由于没有多行注释, 所以每一行都需要添加 `#`
- `echo`:

---

- 基本语法：了解shell的基本语法，如变量、命令、管道等。
- 脚本结构：了解脚本的基本结构，如if、for、while等循环。
- 脚本调试：学习如何调试shell脚本，如使用set命令查看变量值、使用echo命令打印消息等。
- 脚本传参：了解如何将参数传递给脚本，如使用$1、$2等获取参数值。
- 脚本输出：了解如何向控制台输出消息，如使用echo命令、printf命令等。
- 脚本读取输入：了解如何从用户那里读取输入，如使用read命令等。
- 脚本处理错误：了解如何处理脚本中的错误，如使用if命令检查条件、使用trap命令捕获信号等。
- 脚本调用其他脚本：了解如何调用其他脚本，如使用source命令源取脚本、使用eval命令执行脚本等。

### 变量


命名规则:

- 必须以英文字母开头
- 只能使用数字, 字母, 下划线
- 不能使用 bash 关键字

#### 变量的定义

使用`declare`或`typeset`命令定义全局变量：

```sh
declare -xg my_variable="Hello, World!"
# 或者
typeset -g my_variable="Hello, World!"
```

declare是Shell中的一个内部命令，用于声明变量。您可以使用-x选项将变量声明为全局变量，使用-g选项将变量声明为全局变量，使用-a选项将变量声明为数组，使用-p选项从用户那里读取值并定义变量，使用-f选项定义函数，等。

> 使用-x和-g选项可能会有所不同。例如，当您在脚本中使用source命令源取另一个脚本时，全局变量可能会被重新定义，导致错误。在这种情况下，使用-x选项可能更安全。然而，在大多数情况下，这两种选项都可以达到相同的效果。

typeset是另一个内部命令，用于声明变量。与declare命令类似，您可以使用-x选项将变量声明为全局变量，使用-g选项将变量声明为全局变量，使用-a选项将变量声明为数组，使用-p选项从用户那里读取值并定义变量，使用-f选项定义函数等。

> `declare`和`typeset`都是内部命令，用于声明变量。它们之间没有区别，只是语法不同。`typeset`命令主要用于`Bash`脚本，而`declare`命令主要用于`Kornshell`和`Zsh`脚本。

直接使用 `a=xxx` 的形式，这种方法在大多数情况下都可以正常工作。但是，当使用source命令源取另一个脚本时，这种方法可能会导致问题。在这种情况下，使用-x选项可能更安全。例如：

```bash
# 定义时注意等号不留空格
variable=value
```

定义变量时不加 `$`

```sh
source my_script.sh -x
```

这将确保my_script.sh中的全局变量在源脚本中可用。

在脚本中定义局部变量：

在脚本中，您可以使用local关键字定义局部变量。例如：

```sh
local my_variable="Hello, World!"
```

使用read命令从用户那里读取值并定义变量：

```sh
read -p "Enter a value: " my_variable
```

使用export命令将变量输出为环境变量：

```sh
export my_variable="Hello, World!"
```

要在其他脚本中使用这些变量，您可以使用source命令源取这些脚本，或者在调用这些脚本时使用source命令。例如：

```sh
source my_script.sh
# 或者
./my_script.sh
```

#### 使用变量

使用变量时需要加 `$`

```bash
echo $variable

echo ${variable}

# 使用${}用于帮助解释器识别边界 (tips: 这种写法和js具有一致性,方便记忆)
echo "use ${variable}format like this"
```

#### 变量类型

- 局部变量: 定义在脚本或命令中, 只在当前 shell 实例中有效, 无法被其他 shell 实例访问
- 环境变量: 所有程序都能够访问
- shell 变量: shell 程序的特殊变量

#### 特殊变量(shell 变量)

| 变量 | 含义                                                               |
| ---- | ------------------------------------------------------------------ |
| `$0` | 当前脚本的文件名                                                   |
| `$n` | 传递给脚本的参数, `$1`: 是第一个参数, `$2`: 是第二个参数, 依此类推 |
| `$#` | 获取传递参数的个数                                                 |
| `$*` | 获取传递的所有参数                                                 |
| `$@` | 获取传递的所有参数, 参数中包含 `""`时, 与 `$*` 有差异              |
| `$?` | 上一条命令的推出状态, 由 `exit` 设置                               |
| `$$` | 当前 shell 脚本的进程 ID                                           |

##### `$*` 与 `$@`

##### 退出状态

### 输入&输出

#### printf

#### read

### 转义字符

使用 `echo` 输出时默认不转义字符, 添加 `-e` 选项对转义字符进行替换

tips: `echo` 有一个 `-E` 选项, 表示禁止使用转义字符, 这和正则表达式的大写转义符一样用于表示与小写相反的功能

### 命令替换

### 变量替换

### 运算符

#### 算术运算符

#### 关系运算符

#### 布尔运算符

#### 字符串运算符

#### 文件测试运算符

### 字符串

#### 字符串拼接

#### 获取字符串长度

#### 截取字符串

#### 查找字符串

### 数组

### 判断

#### if

#### case

### 循环

#### for

#### while

#### until

#### break

#### continue

### 函数

#### 定义函数

#### 参数

#### 获取返回值

### 输入输出重定向

### Here Document

### /dev/null

### shell 文件包含

### awk

### grep

### sed

## 文件系统

通过 `LVM` 或者 `软件磁盘阵列` 可以一个将一个分区格式化为多个文件系统, 或者将多个分区合成为一个文件系统, 所以我们通常将可挂载的数据称为一个 `可挂载的文件系统` 而不是分区

- `superblock`: 记录所在文件系统的整体信息,包括 `inode` 与 `block`的总量, 使用量, 剩余量, 以及文件系统的相关格式等信息
- `inode`: 记录文件的属性, 每个文件只占用一个 `inode`, 因此能够创建文件的数量与`inode` 的数量相关, 同时记录文件所在的 `block` 号码
- `block`: 实际记录文件的内容, 一个文件可能会占用多个 `block`

关于 `data block`:

- block 大小有 1k, 2k, 4k 并且在格式化时就已经固定
- 每个 block 只能存放一个文件的数据
- 如果数据量小于一个 block 的大小则多出的容量不能被其他文件所使用

关于 `inode`:

`inode` 所包含的文件数据有:

- 文件的存取模式(read/write/excute)
- 文件的拥有者和群组(owner/group)
- 文件的容量
- 文件的创建和改变的时间(ctime)
- 最近一次读取的时间(atime)
- 最近一次修改的时间(mtime)
- 定义文件特性的 flag
- 文件 block 内容的指向(pointer)

`inode` 的一些特性:

- 每个 `inode` 的大小固定为 `128bytes`
- 系统读取文件时需要先读取 `inode` 然后才能判断权限与用户是否符合, 并实际开始读取 `block` 中的文件内容

### 文件系统的类型

linux 常用的文件系统类型， 常见发行版现在多为ext3/4 且ext系都能向上挂载，可以方便的升级无需格式化

- ext
- ext2
- ext3
- ext4

unix 常用的文件系统类型

- XFS
- JFS
- UFS

windows 常用的文件系统类型

- FAT
- NFS

### 类型

### 文件

绝对路径 & 相对路径

- 以根目录为起始的路径形式 为绝对路径
- 不以根目录为起始的路径形式 为相对路径

根据实际需求判断使用何种路径形式，以确保方便或者准确

touch

cat

cp

mv

rm

tar

find

### 目录

几个特殊的目录位置:

- `.` 当前目录
- `..` 上级目录
- `~` 当前用户的家目录
- `~[user]` 指定用户的家目录
- `-` 上次跳转之前的目录

pwd 显示当前目录

mkdir

rmdir

cd

ls

### 挂载

mount

unmount

## 用户

查看用户
`id [option]... [username]...`

```sh
[root@localhost ~]# id www
uid=500(www) gid=500(www) groups=500(www)
```

添加用户

useradd

添加组
groupadd

修改用户
usermod

passwd

userdel

### 群组与用户

- `/etc/passwd` 存放用户信息
- `/etc/shadow` 存放密码
- `/etc/group` 存放群组信息

### 账户与组

## 权限

### 文件权限

## 管理

## linux 根文件系统

```none
/
|-/bin -> /usr/bin
|-/boot
|-/dev
|-/etc
|-/home
|-/root
|-/run
|-/sbin -> /usr/sbin
|-/tmp
|-/usr
    |-/usr/bin
    |-/usr/local
    |-/usr/sbin
    |-/usr/tmp
|-/var
    |-/var/tmp -> /usr/tmp
```

### /bin

主要存放可执行文件
该目录下的命令可以被 root 与一般用户所使用, 由于这些命令在挂接其它文件系统之前就可以使用, 所以`/bin`目录必须和根文件系统在同一个分区中

### /boot

### /debootstrap

### /dev

因为在这个目录中包含了所有 Linux 系统中使用的外部设备

### /etc

该目录下存放着系统主要的配置文件, 例如人员的账号密码文件, 各种服务的其实文件等
一般来说, 此目录的各文件属性是可以让一般用户查阅的, 但是只有 root 有权限修改

### /home

系统默认的用户文件夹, 它是可选的, 对于每个普通用户, 在`/home`目录下都有一个以用户名命名的子目录, 里面存放用户相关的配置文件

### /lib

该目录下存放共享库和可加载(驱动程序), 共享库用于启动系统, 运行根文件系统中的可执行程序, 比如: `/bin`, `/sbin` 目录下的程序

### /lost+found

该目录是使用标准的 ext2/ext3 档案系统格式才会产生的一个目录, 目的在于当系统发生错误时, 将一些遗失的片段放置在这个目录下

该目录一般情况是空的, 只有 root 用户才能打开

lost+found 目录的文件通常是未链接的文件, 这些文件还被一些进程使用(数据没有删除)

### /media

软盘, 光盘, U 盘等等装置挂载位置

### /mnt

镜像,硬盘等

用于临时挂载某个文件系统的挂接点, 通常是空目录, 也可以在里面创建一引起空的子目录, 比如`/mnt/cdram`, `/mnt/hda1` 用来临时挂载光盘, 移动存储设备等

### /misc

其它各类挂载位置

### /opt

是一些大型软件的安装目录, 或者是一些服务程序的安装目录

### /proc

正在运行的内核信息映射

主要输出:

- 进程信息
- 内存资源信息
- 磁盘分区信息等等

这是一个空目录, 常作为 proc 文件系统的挂接点, proc 文件系统是个虚拟的文件系统, 它没有实际的存储设备, 里面的目录, 文件都是由内核
临时生成的, 用来表示系统的运行状态, 也可以操作其中的文件控制系统

### /root

root 的主文件夹, 即是根用户的目录, 与此对应, 普通用户的目录是`/home`下的某个子目录

### /run

里面的东西是系统运行时需要的, 不能随便删除, 但是重启的时候应该抛弃, 下次系统运行时重新生成

### /sbin

该目录下存放系统命令, 即只有 root 能够使用的命令, 系统命令还可以存放在`/usr/sbin`, `/usr/local/sbin`目录下, `/sbin`目录中存放的是基本的系统命令, 它们用于启动系统和修复系统等, 与`/bin`目录相似, 在挂接其他文件系统之前就可以使用`/sbin`, 所以`/sbin`目录必须和根文件系统在同一个分区中

### /srv

主要用来存储本机或本服务器提供的服务或数据(用户主动生产的数据, 对外提供服务)

### /sys

硬件设备的驱动程序信息

### /tmp

用于存放临时文件, 通常是空目录, 一些需要生成临时文件的程序用到的`/tmp`目录下, 所以`/tmp`目录必须存在并可以访问

### /usr

`Unix Software Resource` Unix 操作系统软件资源所放置的目录

### /var

主要针对常态性变动的文件, 包括缓存(cache), 日志(log file)以及某些软件运作所产生的文件

## 网络

## 附录

### 文件颜色

- 绿色: 可执行文件，可执行的程序
- 红色: 压缩文件或者包文件
- 蓝色: 目录
- 白色(灰色): 一般性文件, 如文本文件, 配置文件, 源码文件等
- 浅蓝色: 链接文件, 主要是使用 ln 命令建立的文件
- 黄色: 设备文件
- 红色闪烁(红底): 表示链接的文件有问题了
- 绿底色: 777

## 附录：GNU/Linux 常用软件

### manjaro 如何在多个版本中设置java

在 Manjaro 中，可以使用 archlinux-java 命令来管理并设置系统中安装的多个 Java 版本。您可以按照以下步骤操作：

首先检查系统上已经安装了哪些 Java 版本，可以使用以下命令：

$ archlinux-java status

此命令将显示所有已知的 Java 安装及其状态。您应该看到输出类似于以下内容：

Available Java environments:
java-8-openjdk/jre (default)
java-9-openjdk
java-11-openjdk

其中，“java-8-openjdk/jre” 是默认的 Java 环境，而 “java-9-openjdk” 和 “java-11-openjdk” 则是可用的备选环境。

要切换到另一个 Java 版本，请使用以下命令：

$ sudo archlinux-java set java-11-openjdk

在这里，我们将当前系统的默认 Java 版本切换为 “java-11-openjdk”。如果您想改用其他版本，请使用相应的版本号替换 “java-11-openjdk”。

在更改后，您可以使用以下命令再次检查当前使用的 Java 版本：

$ java -version

这将输出当前正在使用的 Java 版本信息。

使用 archlinux-java 命令，您可以轻松地在不同的 Java 版本之间切换，并确保正在使用所需的版本。
