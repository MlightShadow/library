# linux 知识提要

## 计算机导论

## 关于linux

为了适配unix操作系统, linux同样采用了POSIX规范

## 硬盘

### 插槽与目录名

IDE磁盘目录名与插槽相关
| IDE\Jumper      | Master     | Slave      |
| --------------- | ---------- | ---------- |
| IDE1(Primary)   | `/dev/hda` | `/dev/hdb` |
| IDE2(Secondary) | `/dev/hdc` | `/dev/hdd` |

SATA磁盘/U盘/其他SCSI磁盘的目录名与检测顺序相关, 与插槽代号无关, 其格式为 `/dev/sd[a-p]`

### 磁盘划分

* MBR (Master Boot Record): 主引导记录, 用于安装启动管理程序, `446bytes`
* partition table: 分区表, 用于记录整个磁盘分区状态, `64bytes`

关于主引导记录:

1. `boot loader` 是安装在 MBR 上读取核心内容运行的软件
2. `boot loader` 可以将启动管理功能转交给其他分区内的 `loader`
3. 其他分区内的 `loader` 安装在各自分区的 `启动磁区(boot sector)` 中

关于分区:

1. 对分区表的配置就是对磁盘进行分区
2. 分区表只能记录4条分区记录, `主要(Primary)` 或 `扩展(Extended)`, 注意: `主要分区 + 扩展分区 = 4`, 且 `扩展分区` 做多只能有1个
3. 分区的最小单位是 `柱面(cylinder)`
4. 系统必须参考分区表才能对分区进行数据处理

> 扩展分区并非实际的分区, 只存储一个扩展分区的分区数据, 其中包含若干个逻辑分区的信息

关于 `逻辑分区(logical partition)`:

1. 通过利用扩展分配可以增加逻辑分区
2. IDE中最多59个逻辑分区(5-63), SATA中最多11个逻辑分区(5-15)

### 分区与挂载

### 分区

### 启动

## 系统安装

## shell

### `#!`

定义脚本执行的解释器

### 注释

注释以 `#` 开头, 由于没有多行注释, 所以每一行都需要添加 `#`

### 输入&输出

#### echo

#### printf

#### read

### 变量

#### 定义变量

命名规则:

* 必须以英文字母开头
* 只能使用数字, 字母, 下划线
* 不能使用bash关键字

```bash
# 定义时注意等号不留空格
variable=value
```

定义变量时不加 `$`

#### 使用变量

使用变量时需要加 `$`

```bash
echo $variable

echo ${variable}

# 使用${}用于帮助解释器识别边界 (tips: 这种写法和js具有一致性,方便记忆)
echo "use ${variable}format like this"
```

#### 变量类型

* 局部变量: 定义在脚本或命令中, 只在当前shell实例中有效, 无法被其他shell实例访问
* 环境变量: 所有程序都能够访问
* shell变量: shell程序的特殊变量

#### 特殊变量(shell变量)

| 变量 | 含义                                                               |
| ---- | ------------------------------------------------------------------ |
| `$0` | 当前脚本的文件名                                                   |
| `$n` | 传递给脚本的参数, `$1`: 是第一个参数, `$2`: 是第二个参数, 依此类推 |
| `$#` | 获取传递参数的个数                                                 |
| `$*` | 获取传递的所有参数                                                 |
| `$@` | 获取传递的所有参数, 参数中包含 `""`时, 与 `$*` 有差异              |
| `$?` | 上一条命令的推出状态, 由 `exit` 设置                               |
| `$$` | 当前shell脚本的进程ID                                              |

##### `$*` 与 `$@`

##### 退出状态

### 转义字符

使用 `echo` 输出时默认不转义字符, 添加 `-e` 选项对转义字符进行替换

tips: `echo` 有一个 `-E` 选项, 表示禁止使用转义字符, 这和正则表达式的大写转义符一样用于表示与小写相反的功能

### 命令替换

### 变量替换

### 运算符

#### 算术运算符

#### 关系运算符

#### 布尔运算符

#### 字符串运算符

#### 文件测试运算符

### 字符串

#### 字符串拼接

#### 获取字符串长度

#### 截取字符串

#### 查找字符串

### 数组

### 判断

#### if

#### case

### 循环

#### for

#### while

#### until

#### break

#### continue

### 函数

#### 定义函数

#### 参数

#### 获取返回值

### 输入输出重定向

### Here Document

### /dev/null

### shell文件包含

### awk

### grep

### sed

## 文件系统

通过 `LVM` 或者 `软件磁盘阵列` 可以一个将一个分区格式化为多个文件系统, 或者将多个分区合成为一个文件系统, 所以我们通常将可挂载的数据称为一个 `可挂载的文件系统` 而不是分区

* `superblock`: 记录所在文件系统的整体信息,包括 `inode` 与 `block`的总量, 使用量, 剩余量, 以及文件系统的相关格式等信息
* `inode`: 记录文件的属性, 每个文件只占用一个 `inode`, 因此能够创建文件的数量与`inode` 的数量相关, 同时记录文件所在的 `block` 号码
* `block`: 实际记录文件的内容, 一个文件可能会占用多个 `block`

关于 `data block`:

* block 大小有1k, 2k, 4k并且在格式化时就已经固定
* 每个block只能存放一个文件的数据
* 如果数据量小于一个block的大小则多出的容量不能被其他文件所使用

关于 `inode`:

`inode` 所包含的文件数据有:

* 文件的存取模式(read/write/excute)
* 文件的拥有者和群组(owner/group)
* 文件的容量
* 文件的创建和改变的时间(ctime)
* 最近一次读取的时间(atime)
* 最近一次修改的时间(mtime)
* 定义文件特性的flag
* 文件block内容的指向(pointer)

`inode` 的一些特性:

* 每个 `inode` 的大小固定为 `128bytes`
* 系统读取文件时需要先读取 `inode` 然后才能判断权限与用户是否符合, 并实际开始读取 `block` 中的文件内容

### 权限与目录

#### 群组与用户

* `/etc/passwd` 存放用户信息
* `/etc/shadow` 存放密码
* `/etc/group` 存放群组信息

### 文件权限

### 类型

### 目录

### 权限

### 挂载

### 一些使用

## 用户

### 账户与组

## 管理

## linux 根文件系统

### /bin

主要存放可执行文件
该目录下的命令可以被root与一般用户所使用, 由于这些命令在挂接其它文件系统之前就可以使用, 所以`/bin`目录必须和根文件系统在同一个分区中

### /boot

### /debootstrap

### /dev

因为在这个目录中包含了所有Linux系统中使用的外部设备

### /etc

该目录下存放着系统主要的配置文件, 例如人员的账号密码文件, 各种服务的其实文件等
一般来说, 此目录的各文件属性是可以让一般用户查阅的, 但是只有root有权限修改

### /home

系统默认的用户文件夹, 它是可选的, 对于每个普通用户, 在`/home`目录下都有一个以用户名命名的子目录, 里面存放用户相关的配置文件

### /lib

该目录下存放共享库和可加载(驱动程序), 共享库用于启动系统, 运行根文件系统中的可执行程序, 比如: `/bin`, `/sbin` 目录下的程序

### /lost+found

该目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录, 目的在于当系统发生错误时, 将一些遗失的片段放置在这个目录下

该目录一般情况是空的, 只有root用户才能打开

lost+found目录的文件通常是未链接的文件, 这些文件还被一些进程使用(数据没有删除)

### /media

软盘, 光盘, U盘等等装置挂载位置

### /mnt

镜像,硬盘等

用于临时挂载某个文件系统的挂接点, 通常是空目录, 也可以在里面创建一引起空的子目录, 比如`/mnt/cdram`, `/mnt/hda1` 用来临时挂载光盘, 移动存储设备等

### /misc

其它各类挂载位置

### /opt

是一些大型软件的安装目录, 或者是一些服务程序的安装目录

### /proc

正在运行的内核信息映射

主要输出:

* 进程信息
* 内存资源信息
* 磁盘分区信息等等

这是一个空目录, 常作为proc文件系统的挂接点, proc文件系统是个虚拟的文件系统, 它没有实际的存储设备, 里面的目录, 文件都是由内核
临时生成的, 用来表示系统的运行状态, 也可以操作其中的文件控制系统

### /root

root 的主文件夹, 即是根用户的目录, 与此对应, 普通用户的目录是`/home`下的某个子目录

### /run

里面的东西是系统运行时需要的, 不能随便删除, 但是重启的时候应该抛弃, 下次系统运行时重新生成

### /sbin

该目录下存放系统命令, 即只有root能够使用的命令, 系统命令还可以存放在`/usr/sbin`, `/usr/local/sbin`目录下, `/sbin`目录中存放的是基本的系统命令, 它们用于启动系统和修复系统等, 与`/bin`目录相似, 在挂接其他文件系统之前就可以使用`/sbin`, 所以`/sbin`目录必须和根文件系统在同一个分区中

### /srv

主要用来存储本机或本服务器提供的服务或数据(用户主动生产的数据, 对外提供服务)

### /sys

硬件设备的驱动程序信息

### /tmp

用于存放临时文件, 通常是空目录, 一些需要生成临时文件的程序用到的`/tmp`目录下, 所以`/tmp`目录必须存在并可以访问

### /usr

`Unix Software Resource` Unix操作系统软件资源所放置的目录

### /var

主要针对常态性变动的文件, 包括缓存(cache), 日志(log file)以及某些软件运作所产生的文件

## linux文件颜色

### 绿色

可执行文件，可执行的程序

### 红色

压缩文件或者包文件

### 蓝色

目录

### 白色(灰色)

一般性文件, 如文本文件, 配置文件, 源码文件等

### 浅蓝色

链接文件, 主要是使用ln命令建立的文件

### 黄色

设备文件

### 红色闪烁(红底)

表示链接的文件有问题了

### 绿底色

777
