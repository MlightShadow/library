# cpp

## 基础

### 变量和数据类型

### 常量

### 运算符

### 控制语句

### 函数

### 数组

### 指针

#### 指针的使用

##### 指针的定义和声明

在C++中，指针是一个变量，用来存储另一个变量的内存地址。指针的定义和声明可以通过以下语法实现：

```cpp
// 数据类型 *指针变量名;
int *p;  // 定义一个指向整型变量的指针p

char *p; // 定义一个指向字符型变量的指针p

float *p; // 定义一个指向浮点型变量的指针p

double *p; // 定义一个指向双精度浮点型变量的指针p
```

在定义指针变量时，需要指定指针所指向的数据类型（也可以是自定义类型），并在指针变量名前加上一个星号(*)，表示该变量是一个指针。

指针变量的声明也可以使用 typedef 关键字来定义一个新的类型名，例如：

```cpp
typedef int* IntPtr; // 定义一个指向整型变量的指针类型名IntPtr
IntPtr p; // 定义一个IntPtr类型的指针变量p
```

在声明指针变量后，可以通过给指针赋值来让它指向一个具体的变量，例如：

```cpp
int a = 10;
int *p;
p = &a; // 将指针p指向变量a的地址
```

这样，指针p就指向了变量a的内存地址，可以使用*p来访问该地址上的值，例如：

```cpp
cout << *p; // 输出变量a的值10
```

以上就是指针的定义和声明的基本语法和用法。

##### 指针运算和比较

* 指针运算

    指针是C++编程语言中一种非常重要的数据类型，它用于存储内存地址。指针运算是指在指针变量上进行的数学运算，包括指针加减运算、指针比较运算和指针赋值运算。

    指针加减运算主要用于对指针进行偏移，指向另一个地址。例如，对于一个指向整型变量的指针变量p，p+1的结果是指向下一个整型变量的指针。

    指针比较运算用于比较两个指针的大小关系。如果两个指针指向同一个数组中的元素，那么它们的比较结果可能是相等的或者不相等的。如果两个指针指向不同的数组，或者指向同一个数组中的不同元素，那么它们的比较结果是未定义的。

    指针赋值运算用于将一个指针变量的值赋给另一个指针变量。例如，可以将一个指向整型变量的指针变量p的值赋给另一个指向整型变量的指针变量q，即q=p。

    需要注意的是，在进行指针运算时，必须确保指针指向的内存空间是合法的，否则就可能会出现未定义的行为。同时，指针运算也要遵循C++编程语言的语法规则，例如不能对空指针进行运算等。

* 指针比较

    指针比较是指在C++编程语言中比较两个指针变量的大小关系，其返回值代表两个指针变量指向的内存地址在内存空间中的相对位置关系。

    在C++编程语言中，指针比较运算符包括小于号(<)、大于号(>)、小于等于号(<=)和大于等于号(>=)。指针变量的比较运算符只能用于指针类型之间的比较，不能用于其他类型之间的比较。

    指针比较的规则如下：

    1. 如果两个指针变量指向同一块内存空间，则它们相等。

    2. 如果两个指针变量指向同一块内存空间中的不同元素，则它们的大小关系由它们指向的元素在内存中的相对位置决定。

    3. 如果两个指针变量指向不同的内存空间，则它们的大小关系由它们指向的内存空间在内存中的相对位置决定。如果指向的内存空间地址小的指针变量在内存中出现在指向的内存空间地址大的指针变量之前，则前者小于后者，反之则大于后者。

    需要注意的是，在进行指针比较时，必须确保指针指向的内存空间是合法的，否则就可能会出现未定义的行为。同时，指针比较也要遵循C++编程语言的语法规则，例如不能对空指针进行比较等。

##### 指针和数组

C++中指针和数组是密不可分的。数组名本身就是一个指向数组第一个元素的指针，也就是数组名可以被看成是指向数组首元素地址的常量指针。下面是一些指针和数组相关的语法：

1. 声明一个指向数组元素的指针

    ```cpp
    int arr[10];
    int* ptr = arr; // 等价于 int* ptr = &arr[0];
    ```

2. 通过指针访问数组元素

    ```cpp
    int arr[10];
    int* ptr = arr;
    cout << ptr[0] << endl; // 等价于 cout << arr[0] << endl;
    cout << ptr[1] << endl; // 等价于 cout << arr[1] << endl;
    ```

3. 通过指针遍历数组

    ```cpp
    int arr[10];
    int* ptr = arr;
    for (int i = 0; i < 10; i++) {
        cout << ptr[i] << endl; // 等价于 cout << arr[i] << endl;
    }
    ```

4. 指针算术运算

    ```cpp
    int arr[10];
    int* ptr = arr;
    ptr++; // 指向下一个元素
    ptr--; // 指向上一个元素
    ```

需要注意的是，在使用指针和数组时，必须确保指针指向的内存空间是合法的，否则就可能会出现未定义的行为。同时，指针和数组也要遵循C++编程语言的语法规则，例如不能访问越界的数组元素等。

##### 指针和函数

指针和函数在C++编程语言中都是非常重要的概念。

指针可以理解为一个变量，它存储的是另一个变量的地址。使用指针可以直接访问该变量，或者通过指针传递变量的地址给函数，从而在函数中修改该变量的值。

函数是一段可以重复调用的代码块，它可以接收参数并返回值。在C++中，函数可以使用指针作为参数，从而实现对参数的修改或返回多个值。

举个例子，下面的代码演示了如何使用指针作为函数的参数：

```cpp
#include <iostream>

void addOne(int* num) {
    (*num)++;
}

int main() {
    int num = 10;
    std::cout << "Before: " << num << std::endl;
    addOne(&num);
    std::cout << "After: " << num << std::endl;
    return 0;
}
```

在上面的代码中，我们定义了一个函数`addOne`，它接收一个指向整数的指针作为参数。函数的作用是将指针指向的整数加1。在`main`函数中，我们定义了一个整数`num`，然后调用`addOne`函数并传递`num`的地址作为参数。最后输出`num`的值，可以看到`num`的值已经被修改了。

指针和函数的结合使用可以让我们更加灵活地编写程序，提高代码的可读性和可维护性。

##### 指针进行动态分配内存

指针可以用来进行动态内存分配，动态内存分配是指在程序运行时根据需要进行内存分配和释放的过程。在C++中，动态内存分配主要通过new和delete操作符来实现。

new操作符用于在堆上分配一块指定大小的内存，并返回其地址，示例代码如下：

```cpp
int* p = new int; // 分配一个int大小的内存块
```

在这个例子中，new操作符会在堆上分配一个int大小的内存块，并返回这块内存的首地址，我们可以将其保存在一个指向int类型变量的指针p中。

如果需要分配一块连续的内存块，可以使用new[]操作符，示例代码如下：

```cpp
int* p = new int[10]; // 分配一个包含10个int类型元素的数组
```

在这个例子中，new[]操作符会在堆上分配一块大小为10个int类型元素的连续内存块，并返回这块内存的首地址，我们可以将其保存在一个指向int类型变量的指针p中。

使用完动态分配的内存后，需要用delete或delete[]操作符释放内存，示例代码如下：

```cpp
delete p; // 释放单个变量p指向的内存块
delete[] p; // 释放数组p指向的内存块
```

需要注意的是，delete操作符只能用于释放通过new操作符分配的单个变量内存块，而delete[]操作符只能用于释放通过new[]操作符分配的数组内存块。否则就会导致内存泄漏或未定义行为。

在多次使用同一指针进行动态分配时也应当先释放再重新进行动态分配内存。

##### 指针的类型转换

指针类型转换是指将一个指针变量的数据类型转换为另一个数据类型。在编程中，需要进行指针类型转换的情况有很多，比如将void指针转换为其他指针类型、将基本数据类型的指针转换为类的指针类型等等。

在C++中，指针类型转换可以使用强制类型转换符进行。强制类型转换符包括static_cast、dynamic_cast、reinterpret_cast、const_cast四种。

* static_cast: 用于基本数据类型之间的转换，或者将指针或引用转换为void指针或void引用。

* dynamic_cast: 用于类之间的转换，具有运行时类型检查的功能，只能用于指向类对象的指针或引用。

* reinterpret_cast: 用于指针类型之间的转换，可以将任何指针类型转换为任何其他指针类型，但是不进行类型检查，慎用。

* const_cast: 用于将const指针或引用转换为非const指针或引用，也可以用于将volatile指针或引用转换为非volatile指针或引用。

需要注意的是，指针类型转换可能会导致程序出现未定义行为或错误，因此需要谨慎使用。

### 结构体和联合体

好的，C++中的结构体和联合体都是用来组织数据的数据类型。它们的区别在于：

* 结构体：结构体是一种可以存储不同数据类型的组合数据类型。结构体中的每个成员都有自己的名称和数据类型，可以通过结构体变量来访问结构体中的成员。

* 联合体：联合体是一种特殊的结构体，它只能同时存储其中的一个成员，所有成员共享同一块内存空间。联合体的大小等于最大成员的大小。

下面是一个结构体和一个联合体的示例：

```cpp
#include <iostream>
using namespace std;

// 定义一个结构体
struct student {
    char name[20];
    int age;
    float score;
};

// 定义一个联合体
union data {
    int i;
    float f;
    char c;
};

int main() {
    // 使用结构体
    student s1;
    strcpy(s1.name, "Tom");
    s1.age = 20;
    s1.score = 89.5;
    cout << "Name: " << s1.name << endl;
    cout << "Age: " << s1.age << endl;
    cout << "Score: " << s1.score << endl;

    // 使用联合体
    data d;
    d.i = 10;
    cout << "i: " << d.i << endl;
    d.f = 3.14;
    cout << "f: " << d.f << endl;
    d.c = 'A';
    cout << "c: " << d.c << endl;
    return 0;
}
```

输出结果：

```txt
Name: Tom
Age: 20
Score: 89.5
i: 10
f: 3.14
c: A
```

在这个示例中，我们定义了一个结构体`student`和一个联合体`data`，并在`main()`函数中使用它们。我们可以看到，结构体`student`中有三个成员，分别是`name`、`age`和`score`，而联合体`data`中只有一个成员，但其类型可以是`int`、`float`或`char`中的任意一种。

### 输入输出

C++中的输入和输出可以通过标准库中的iostream头文件进行操作。常用的输入和输出方式有cin和cout。

cin用于从输入流中读取数据，可以使用>>符号将数据读入到变量中。例如：

```cpp
int num;
cin >> num;
```

cout用于向输出流中输出数据，可以使用<<符号将数据输出。例如：

```cpp
cout << "Hello, World!" << endl;
```

其中endl表示换行符。

除了cin和cout之外，C++还提供了一些其他的输入输出方式，比如：

* getline：用于从输入流中读取一行数据。
* setw：用于设置输出宽度。
* setprecision：用于设置输出精度。

例如：

```cpp
string name;
getline(cin, name);
cout << setw(10) << setprecision(2) << 3.1415926 << endl;
```

这段代码将从输入流中读取一行字符串，然后向输出流中输出一个宽度为10，精度为2的浮点数。

## 面向对象

C++是一种支持面向对象编程的语言，它提供了类、对象、继承、多态等面向对象编程的特性。

### 类

类是面向对象编程的基础，可以将类看作是一种数据类型的定义，包含了数据成员和成员函数。数据成员是类的属性，成员函数是类的操作。类可以通过访问控制符来控制数据成员和成员函数的访问权限，包括public、private和protected。

C++中类是一种自定义的数据类型，用于封装数据和函数。类定义了一些属性和方法，可以通过创建类的实例（对象）来访问这些属性和方法。

类的定义通常包括以下几个部分：

* 类声明：包括类名和成员函数原型，用于描述类的接口。
* 类定义：包括类的数据成员和成员函数的实现，用于描述类的实现。
* 构造函数和析构函数：用于创建和销毁对象。
* 访问控制符：用于控制数据成员和成员函数的访问权限，包括public、private和protected。

例如，下面是一个简单的类的定义：

```cpp
class Person {
public:
    Person(string name, int age);
    void sayHello();
private:
    string name;
    int age;
};
```

这个类叫做Person，包括一个公有构造函数和一个公有成员函数sayHello，以及两个私有数据成员name和age。公有的构造函数用于初始化对象的数据成员，公有的成员函数sayHello用于输出一段问候语。

类的声明和定义可以分别在.h和.cpp文件中实现，或者直接在一个文件中实现。类的使用通常可以通过创建对象、调用成员函数和访问数据成员来实现，例如：

```cpp
Person p("Alice", 20);
p.sayHello();
```

这个代码创建了一个名为p的Person对象，调用了它的sayHello函数。

总之，类是C++面向对象编程的基础，通过封装数据和函数，可以让代码更加模块化和可复用。掌握类的定义和使用是C++编程的基础。

对象是类的实例化，通过使用类定义的构造函数可以创建对象。对象可以调用类中的成员函数，并可以访问类的数据成员。

### 类的继承

继承是一种类与类之间的关系，可以使一个类继承另一个类的数据成员和成员函数，从而使代码重用更加方便。派生类继承了基类的所有公有和保护成员，并可以在其中添加自己的成员。

C++中的继承是指在一个类中定义另一个类的特性，即基类和派生类的关系。派生类可以使用基类的所有成员和函数，并且可以添加自己的成员和函数。

在C++中，使用关键字`class`定义类，并使用`public`、`protected`和`private`关键字来控制成员的访问权限。在定义派生类时，使用关键字`class`后面加上冒号和基类的名称来指定基类，然后再定义派生类的成员和函数。

例如，假设有一个基类`Animal`，它有一个`eat()`函数和一个`name`成员变量。现在我们要定义一个派生类`Dog`，它继承自`Animal`，并且有一个`bark()`函数和一个`age`成员变量，可以这样实现：

```cpp
class Animal {
public:
    void eat();
    string name;
};

class Dog : public Animal {
public:
    void bark();
    int age;
};
```

在上面的代码中，`Dog`类继承自`Animal`类，并且使用`public`关键字指定继承方式为公有继承。这意味着`Dog`类可以访问`Animal`类的所有公有成员和函数。同时，`Dog`类还添加了自己的成员变量`age`和函数`bark()`。

继承可以让代码更加简洁和易于维护，因为相似的类可以共享代码，而不需要重复编写。此外，继承还可以实现多态性，即同一个函数可以在不同的派生类中具有不同的实现。

多态是一种在派生类中重写基类方法的方式，可以使基类指针指向派生类对象并调用重写的方法。多态能够提高代码的可扩展性和可维护性，可以使代码更加灵活。

在C++中，面向对象编程可以通过类、对象、继承和多态等特性来实现。对于面向对象编程的学习，需要掌握类的定义和使用、对象的创建和使用、继承和派生类的定义和使用、多态的概念和实现等知识点。

## 数据结构和算法

## 内存管理

## 泛型编程

## C++标准库

## C++编程规范
