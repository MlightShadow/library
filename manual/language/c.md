# C

## C语言用途和语言标准

### 用途

C语言在许多领域都有广泛的应用。以下是一些主要用途：

1. **系统编程**：C语言具有可移植性好、性能高、能够直接访问硬件地址等特点，适合开发操作系统和嵌入式应用程序。
2. **应用软件和游戏开发**：C语言被广泛应用于实现最终的用户应用程序，或者作为某些应用程序的关键模块，例如机械设计领域的各种CAM和CAD都在使用C语言编写某些关键模块。此外，手机、PDA等时尚消费类电子产品中的应用软件和游戏等也大量使用C语言进行开发。
3. **网络程序和服务器端底层开发**：对于性能要求严格的地方，例如网络程序的底层和网络服务器端底层，通常会使用C语言进行开发。
4. **系统软件和图形处理**：C语言具有很强的绘图能力和可移植性，并且具备很强的数据处理能力，可以用来编写系统软件、制作动画、绘制二维图形和三维图形等。
5. **数字计算**：相对于其他编程语言，C语言是数字计算能力超强的高级语言，因此在需要进行高性能数字计算的应用中常常被使用。
6. **嵌入式设备开发**：C语言在嵌入式设备开发中也有大量应用，例如手机、PDA等设备中的应用程序和游戏等很多都是采用C语言进行开发的。

以上是C语言的一些主要用途，实际上，C语言在很多领域都可以使用，具有非常广泛的应用范围。

### 标准

C语言的语言标准指的是定义C语言语法、数据类型、运算符等规则的标准文档。C语言的标准文档有多种，其中最广泛使用的是以下三种：

1. C89/C90标准：也称为ANSI C，是C语言的第一个标准，于1989年或1990年由美国国家标准协会（ANSI）制定。这个标准包含了C语言的基本语法和基本数据类型，但对标准库的要求较少。
2. C99标准：是C语言的第二个正式标准，于1999年由国际标准化组织（ISO）制定。在C89/C90的基础上，C99增加了很多新的特性，包括更丰富的数据类型、变长数组、复合字面量等，同时对标准库进行了扩充。
3. C11标准：是C语言的第三个正式标准，于2011年由ISO制定。在C99的基础上，C11修正了一些问题，并增加了一些新特性，如多线程支持、对Unicode字符的更好支持等。

在实际开发中，使用哪个版本的C语言标准取决于编译器的支持情况和项目需求。一般来说，新项目可以选择使用C99或C11标准，而一些旧的项目可能还使用C89/C90标准。

## C语言概述第一个C语言程序

## 数据和C语言基本数据类型

C语言有以下数据类型：

1. **基本类型**：包括整型、浮点型、字符型。

    * 整型（int）：有符号短整型（short int）、有符号长整型（long int）、无符号短整型（unsigned short int）、无符号长整型（unsigned long int）。
    * 浮点型（float）：单精度浮点数。
    * 字符型（char）：单个字符或字符的ASCII码。

2. **构造类型**：由若干种类型组合而成。

    * 数组（Array）：由同一种类型的数据组成。
    * 结构体（Struct）：可以由不同类型的数据组成。
    * 枚举类型（Enum）：当一个变量只允许有几个固定取值时使用。
    * 共用体（Union）：多个变量公用一个内存地址。

3. **空类型**：void，主要用于函数的返回类型，表示无返回值。
4. **指针类型**：指针是一种数据类型，它存储了一个内存地址，间接操作变量的值。

以上就是C语言的数据类型，它们提供了丰富的表达方式，以支持各种复杂的计算和数据处理需求。

## 字符串和格式化输入/输出

### 字符串

在C语言中，字符串是通过字符数组来表示的，而不是通过单独的字符类型变量。

字符型变量（`char`）在C语言中通常用于表示单个字符，而字符串是由一个字符数组存储的一系列字符。字符串的结尾是一个特殊的字符`\0`（空字符），用于标识字符串的结束。

下面是一个示例，演示如何在C语言中声明和初始化一个字符串：

```c
#include <stdio.h>

int main() {
    char str[] = "Hello, World!"; // 声明并初始化一个字符数组来存储字符串
    printf("%s\n", str); // 输出字符串
    return 0;
}
```

在上面的示例中，`str`是一个字符数组，它被初始化为包含字符串`"Hello, World!"`。字符串字面量中的字符存储在数组中，并且该数组以`\0`结尾。

当你使用`printf`函数时，它知道如何识别字符串的结束并停止打印。

需要注意的是，C语言标准没有规定字符串的具体实现方式，但是大多数编译器使用字符数组来表示字符串。

### 格式化输入输出

在C语言中，格式化输入输出是指按照指定格式进行输入和输出操作。

格式化输入是指将输入的数据按照指定的格式进行处理，例如从键盘输入的数据通常是字符串或数字，我们可以使用scanf()函数按照指定的格式读取输入的数据，比如读取整数、浮点数、字符、字符串等类型的数据，也可以读取多种类型的数据混合。

格式化输出是指将需要输出的数据按照指定的格式显示在屏幕上或者文件中，例如可以使用printf()函数按照指定的格式输出整数、浮点数、字符、字符串等类型的数据，也可以输出多种类型的数据混合。

在C语言中，格式化输入输出需要使用格式化字符串来指定输出的格式，例如"%d"表示输出整数，"%.2f"表示输出浮点数并保留两位小数，"%"表示输出一个字符等。同时，还需要提供需要输出的数据，可以是常量、变量或表达式等。

## 运算符、表达式和语句

C语言中有很多种运算符，以下是一些常见的运算符：

1. 算术运算符：用于进行数学运算，包括加（+）、减（-）、乘（*）、除（/）、取模（%）、递增（++）、递减（--）等。
2. 赋值运算符：用于给变量赋值，包括等于（=）、加等于（+=）、减等于（-=）、乘等于（*=）、除等于（/=）、模等于（%=）、位左移等于（<<=）、位右移等于（>>=）等。
3. 比较运算符：用于比较两个值的大小，包括等于（==）、不等于（!=）、大于（>）、小于（<）、大于等于（>=）、小于等于（<=）等。
4. 逻辑运算符：用于进行逻辑运算，包括与（&&）、或（||）、非（!）等。
5. 位运算符：用于对二进制位进行运算，包括位与（&）、位或（|）、位非（~）、位异或（^）、左移（<<）、右移（>>）等。
6. 条件运算符（三目运算符）：用于在三个表达式中选择一个，格式为（条件）？表达式1：（表达式2）。
7. 类型转换运算符：用于将一种数据类型转换为另一种数据类型，包括强制类型转换（）、静态类型转换（）和动态类型转换（）等。
8. sizeof运算符：用于获取一个类型或变量所占用的内存大小，格式为sizeof（类型名）或sizeof（变量名）。
9. &运算符：用于获取变量的地址。
10. *运算符：用于指针变量，表示指针所指向的变量的值或地址。

除了以上这些运算符，C语言还有一些其他的运算符，如break、continue、return等控制流运算符，以及sizeof、&等操作符。这些运算符的使用方式和功能各不相同，具体的用法可以参考C语言的文档或教材。

## 循环语句while、for 和条件运算符

在C语言中，我们主要使用`for`，`while`和`do...while`循环来实现循环。

**1. For循环：**

这是最常用的循环类型，一般用于已知循环次数的情况。

```c
for(int i = 0; i < 10; i++) {
    printf("%d\n", i);
}
```

上面的代码会打印从0到9的所有数字。

**2. While循环：**

这种循环一般用于未知循环次数，但需要满足某个条件才停止循环的情况。

```c
int i = 0;
while(i < 10) {
    printf("%d\n", i);
    i++;
}
```

上面的代码和`for`循环打印的内容是一样的，但采用了`while`循环。

**3. Do...While循环：**

这种循环至少执行一次，然后再满足某个条件的情况下继续执行。

```c
int i = 0;
do {
    printf("%d\n", i);
    i++;
} while(i < 10);
```

以上的代码会打印从0到9的所有数字，和前两种循环一样。

在C语言中，循环是非常重要的部分，可以用来重复执行一段代码，以实现各种复杂的功能。在使用循环时，一定要注意避免出现死循环，否则程序可能会陷入无法结束的困境。

## 控制语句if else、continue分支和跳转goto

C语言中有多种控制语句，这些语句用于控制程序的流程。以下是一些主要的控制语句：

1. **条件语句**：这些语句用于根据特定条件执行不同的操作。它们包括 if 语句和 switch 语句。

    * **if 语句**：如果指定的条件为真，if 语句就执行一组语句。例如：

        ```c
        if (x > 10) {
            printf("x is greater than 10");
        }
        ```

    * **if...else 语句**：如果 if 语句中的条件为假，else 语句就会执行另一组语句。例如：

        ```c
        if (x > 10) {
            printf("x is greater than 10");
        } else {
            printf("x is not greater than 10");
        }
        ```

    * **switch 语句**：switch 语句根据一个变量的值来执行不同的语句块。例如：

        ```c
        switch (day) {
            case 1:
                printf("Monday");
                break;
            case 2:
                printf("Tuesday");
                break;
            default:
                printf("Another day");
        }
        ```

2. **循环语句**：这些语句用于重复执行一组语句，直到满足特定条件。包括 for、while 和 do...while 循环。

    * **for 循环**：for 循环在指定的次数内重复一组语句。例如：

        ```c
        for (int i = 0; i < 10; i++) {
            printf("%d\n", i);
        }
        ```

    * **while 循环**：while 循环在条件为真时重复一组语句。例如：

        ```c
        int i = 0;
        while (i < 10) {
            printf("%d\n", i);
            i++;
        }
        ```

    * **do...while 循环**：do...while 循环至少执行一次，然后在条件为真时重复执行。例如：

        ```c
        int i = 0;
        do {
            printf("%d\n", i);
            i++;
        } while (i < 10);
        ```

3. **跳转语句**：这些语句用于控制程序流程的直接跳转，包括 break、continue 和 goto 语句。

    * **break 语句**：break 语句可以用于跳出当前循环或 switch 语句。例如，在 switch 语句中：

        ```c
        switch (day) {
            case 1:
                printf("Monday");
                break;  // 跳出 switch 语句
            case 2:
                printf("Tuesday");
                break;
            default:
                printf("Another day");
        }
        ```

## 字符输入/输出和输入getchar、putchar

C语言中的字符串输入输出以及getchar和putchar是用于字符和字符串处理的常用函数。

在C语言中，字符串被表示为字符数组，以null字符（\0）结束。字符串的输入通常使用scanf函数，例如：

```c
char str[100];
scanf("%s", str);  // 输入一个字符串
```
在上面的示例中，通过scanf函数输入一个字符串，将其存储在名为str的字符数组中。

对于字符串的输出，可以使用printf函数，例如：

```c
char str[] = "Hello, world!";
printf("%s\n", str);  // 输出字符串
```

在上面的示例中，通过printf函数输出一个名为str的字符数组中的字符串。

getchar和putchar是C标准库中的字符输入输出函数。getchar函数从标准输入（通常是键盘）读取一个字符，并返回其ASCII码值。putchar函数将一个字符写入标准输出（通常是显示器）。例如：

```c
#include <stdio.h>

int main() {
    char c;
    printf("Enter a character: ");
    c = getchar();  // 从标准输入读取一个字符
    printf("You entered: %c\n", c);  // 将读取的字符写入标准输出
    return 0;
}
```

在上面的示例中，getchar函数从标准输入读取一个字符，并将其存储在变量c中。然后，通过printf函数将该字符写入标准输出。

以下是putchar函数的一个简单使用示例：

```c
#include <stdio.h>

int main() {
    char c = 'A';
    putchar(c);  // 输出字符'A'
    return 0;
}
```

在上面的示例中，putchar函数将字符'A'输出到标准输出（通常是显示器）。

## 函数和递归，ANSI C函数原型

### 函数

C语言的函数是完成特定任务的独立程序代码单元，可以省去编写重复代码的苦差。函数由返回值类型、函数名和参数组成。根据函数名的不同，我们可以将函数分为库函数和自定义函数。

库函数是在C标准库中提供的函数，例如IO函数（printf、scanf、getchar、putchar）、字符串操作函数（strcmp、strlen）、字符操作函数（toupper）、内存操作函数（memcpy、memcmp、memset）、时间/日期函数（time）和数学函数（sqrt、pow）等。

自定义函数是根据实际需求，程序员自己编写的函数。在C语言中，我们可以通过一个例子来深入了解自定义函数的定义和声明方法。例如：

```c
#include <stdio.h>

// 声明一个自定义函数，该函数的功能是将两个整数相加
int add(int a, int b);

int main() {
    int num1 = 10, num2 = 20;
    int sum = add(num1, num2);  // 调用自定义函数，将num1和num2相加
    printf("The sum of %d and %d is %d\n", num1, num2, sum);
    return 0;
}

// 定义一个自定义函数，该函数的功能是将两个整数相加
int add(int a, int b) {
    return a + b;
}
```

在上面的示例中，我们定义了一个名为add的自定义函数，该函数将两个整数相加并返回它们的和。在主函数中，我们声明了两个整数变量num1和num2，然后调用add函数将它们相加并将结果赋值给变量sum。最后，我们使用printf函数输出结果。

此外，C语言的函数还可以进行嵌套调用和链式访问。嵌套调用是指在一个函数内部调用另一个函数，例如：

```c
#include <stdio.h>

// 声明一个自定义函数，该函数的功能是计算两个数的和
int add(int a, int b);

// 声明一个自定义函数，该函数的功能是计算三个数的和
int add_three(int a, int b, int c);

int main() {
    int num1 = 10, num2 = 20, num3 = 30;
    int sum = add_three(num1, num2, num3);  // 调用自定义函数，将num1、num2和num3相加
    printf("The sum of %d, %d and %d is %d\n", num1, num2, num3, sum);
    return 0;
}

// 定义一个自定义函数，该函数的功能是将两个整数相加
int add(int a, int b) {
    return a + b;
}

// 定义一个自定义函数，该函数的功能是将三个整数相加
int add_three(int a, int b, int c) {
    return add(a, add(b, c));  // 嵌套调用add函数
}
```

在上面的示例中，我们定义了两个自定义函数：add和add_three。add函数将两个整数相加并返回它们的和，而add_three函数则将三个整数相加并返回它们的和。在add_three函数中，我们嵌套调用了add函数来计算前两个整数的和，然后将这个和与第三个整数相加。

### ANSI C

ANSI C的函数原型是函数声明的扩展，它包括函数返回类型、参数数量和每个参数的类型。

在ANSI C之前，函数声明只需要声明函数的类型，不需要声明任何参数，这会导致如果调用函数时使用的参数个数不对或类型不匹配，编译器不会察觉出错误，只有在运行时才能发现。

而ANSI C的函数原型解决了这个问题，它强制要求在函数声明时声明变量类型，即使用函数原型来声明函数的返回类型、参数的数量和每个参数的类型。这样可以让编译器检查函数调用类型和参数个数是否有错，提高了代码的可读性和安全性。

ANSI C的函数原型借鉴自C++，C++为了支持函数重载，只有在函数名和参数类型一起生成链接名字才能确定是哪个函数，这个过程称为name mangling。

总的来说，ANSI C的函数原型是一种增加函数声明信息的方式，提高了编译器对函数调用的要求和代码的可读性和安全性。

对于函数原型的具体演示，我们无法直接展示，但可以借助以下例子来理解。

假设有如下函数原型：

```c
double calculate(int a, double b);
```

这个函数原型声明了一个名为 `calculate` 的函数，它返回一个 `double` 类型的数据，并接受两个参数，一个是 `int` 类型的 `a`，另一个是 `double` 类型的 `b`。

根据这个原型，以下是一个符合要求的 `calculate` 函数的实现：

```c
double calculate(int a, double b) {
    return a * b;
}
```

在这个实现中，函数名是 `calculate`，返回类型是 `double`，并且接受两个参数，一个是 `int` 类型的 `a`，另一个是 `double` 类型的 `b`。函数体内执行的是将这两个参数相乘并返回结果。

这样，在主函数中调用 `calculate` 函数时，编译器会根据传入的参数类型和数量，自动匹配正确的函数进行调用，避免了因参数类型不匹配或函数调用错误导致的程序错误。

以上例子仅供参考，如需更多了解C语言函数原型的使用，建议查阅相关书籍或文献。

### 递归

C语言中可以使用递归实现许多函数，以下是一个使用递归实现的计算斐波那契数列的C语言函数示例：

```c
#include <stdio.h>

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}

int main() {
    int n = 10;
    printf("Fibonacci(%d) = %d\n", n, fibonacci(n));
    return 0;
}
```

上面的代码中，fibonacci函数是一个递归函数，它返回斐波那契数列中第n个数的值。当n小于或等于1时，函数直接返回n的值。否则，它将递归调用自己来计算前两个数的和，并返回结果。

在主函数中，我们定义了一个变量n，它表示要计算的斐波那契数列的索引。我们然后调用fibonacci函数，将n作为参数传递给它，并打印出返回的结果。

## 数组和指针，多维数组和变长数组

数组是一种用于存储同一种类型的集合的数据结构，它是一种有序的线性表。在程序设计中，为了方便处理，人们把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合被称为数组。

在C语言中，数组属于构造数据类型，一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。C语言的数组按维数可以分为一维、二维和多维，按数组元素的类型则可分为数值数组、字符数组、指针数组、结构体数组等各种类别。

数组的优点在于支持随机访问，即当你想访问数组的某个元素时，只需要找到该数组的对应下标就可以直接找到该元素。但是，数组的元素个数和数组空间大小在创建时就已经被固定死了，如果空间没有使用完会造成空间浪费，并且因为数组的地址是连续的，当进行删除或增加元素的操作时，可能需要进行O(n)的操作。

关于数组的使用，要注意以下几点：

1. 数组是有序数据的集合，用数组名标识，数组元素需属同一数据类型，用数组名和下标确定。
2. 一维数组的定义：数据类型 数组名[常量表达式]。
3. 程序运行时对数组分配连续的内存空间，数组空间大小=数组维数*sizeof(元素数据类型)。
4. 数组元素个数的下标从0开始。
5. C语言对数组不作越界检查，使用时要注意。
6. C语言中无字符串变量，是用字符数组处理字符串，字符串结束标志为字符'\0'。

在实际使用中，还需要结合实际需求和数据结构的特点来进行设计和选择。

首先，数组是C语言中用于存储相同类型数据元素的数据结构。你可以这样定义一个数组：

```c
int array[10];
```

这里，`array`是一个整型数组，名字是`array`，大小为10。注意，数组的大小在定义时必须是固定的。

然后，多维数组是数组的扩展。它允许你创建一个数组的数组。例如：

```c
int array[10][5];
```

这里，`array`是一个10x5的二维整型数组。你可以将它看作一个10个元素的一维数组，每个元素又是一个包含5个整型的数组。

最后，变长数组（VLA，Variable Length Array）在C99标准中引入，允许你在运行时指定数组的大小。例如：

```c
int n;
scanf("%d", &n);
int array[n];
```

这里，`array`的大小是在运行时由`n`决定的。

然而，请注意，变长数组在某些编译器（如gcc在-std=c89和-std=gnu89模式下）并不支持，可能在所有环境下都不是完全可移植的。如果你需要可移植性，或者需要动态地改变数组的大小，那么可能需要使用动态内存分配函数（如malloc、calloc、realloc和free）来创建和销毁动态数组。

好的，以下是C语言中数组、多维数组和变长数组的使用演示：

首先，我们来看一下数组的使用。在C语言中，数组是通过索引访问的，可以通过下标来访问数组元素。例如，如果我们有一个名为`arr`的数组，我们可以通过`arr[index]`来访问第index个元素。

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};

    for(int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}
```

其次，我们来看一下多维数组的使用。多维数组可以看作一个特殊的一维数组，其每一个元素都是一个一维数组。我们可以使用两个下标来访问多维数组中的元素。例如，如果我们有一个名为`matrix`的二维数组，我们可以通过`matrix[i][j]`来访问第i行第j列的元素。

```c
#include <stdio.h>

int main() {
    int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    for(int i = 0; i < 3; i++) {
        for(int j = 0; j < 3; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

最后，我们来看一下变长数组的使用。变长数组在C99标准中引入，允许你在运行时指定数组的大小。例如，你可以通过以下方式创建一个动态大小的数组：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int arr[n];  // This is a variable length array. The size is determined at run time.

    for(int i = 0; i < n; i++) {
        arr[i] = i;
        printf("%d ", arr[i]);
    }

    return 0;
}
```

在C和C++等语言中，指针和数组有着密切的关系。以下是它们之间的一些主要联系和差异：

1. 联系：

    * 数组名是一个指向数组第一个元素的指针。因此，数组名可以隐式地转换为指向其第一个元素的指针。
    * 通过指针，我们可以访问数组的元素。例如，如果我们有一个整数数组arr和一个指向整数的指针ptr，我们可以通过`ptr[i]`来访问数组的第i个元素，其中i是数组的索引。在底层，这将转化为`*(ptr + i)`，其中`*`是解引用运算符，它返回指针指向的值。
2. 差异：

    * 数组是一个固定大小的数据结构，它在内存中占有一块连续的空间。另一方面，指针是一个变量，可以存储任何类型的内存地址，包括数组的地址。
    * 数组的索引是在编译时确定的，因为它们是常量表达式。指针的索引则是在运行时确定的，因为它们是变量。
    * 数组不能被赋值给指针，但指针可以被赋值给另一个指针。例如，我们可以有一个指向整数的指针ptr1，然后我们可以把ptr1赋值给另一个指向整数的指针ptr2。
    * 数组一旦定义就不能改变大小，而指针可以动态地指向不同大小的内存块。

这些关系在理解和编写C和C++代码时非常重要。它们帮助我们理解和操作内存，这是这些语言的核心部分。

在C语言中，指针的使用可以涉及许多不同的情境。以下是关于C语言指针的一些更常见的使用方式：

1. 作为形参：

    指针可以作为函数的形参。当指针作为形参时，它可以用来传递数组、字符串、函数等。在这种情况下，可以通过指针来访问和修改这些数据结构的内容。

    例如，传递数组：

    ```c
    void printArray(int* arr, int size) {
        for(int i = 0; i < size; i++) {
            printf("%d ", arr[i]);
        }
    }

    int main() {
        int arr[5] = {1, 2, 3, 4, 5};
        printArray(arr, 5);  // Output: 1 2 3 4 5
    }
    ```

    在这个例子中，`printArray`函数接收一个指向整型数组的指针和数组的大小，然后打印数组的每个元素。

2. 作为返回值：

    在C语言中，函数可以返回一个指针。返回指针的用处之一是实现数据的共享和传递。

    例如，分配内存并返回指针：

    ```c
    int* createArray(int size) {
        int* arr = (int*)malloc(size * sizeof(int));  // Allocate memory for the array
        if(arr == NULL) {  // Check if memory allocation was successful
            printf("Memory allocation failed\n");
            return NULL;
        }
        return arr;  // Return pointer to allocated memory
    }

    int main() {
        int* arr = createArray(5);  // Get a pointer to allocated memory
        if(arr != NULL) {  // Check if memory allocation was successful
            for(int i = 0; i < 5; i++) {
                arr[i] = i;
            }
        } else {
            printf("Failed to allocate memory\n");
        }
        return 0;
    }
    ```

    在这个例子中，`createArray`函数分配内存，填充数据并返回一个指向这块内存的指针。通过这种方式，可以在函数之间共享和传递数据。注意在使用后需要释放该内存，防止内存泄漏。

3. 与指针变量一起使用：
    在C语言中，指针变量是用来存储内存地址的变量。它可以用来访问存储在该地址的值，也可以用来修改该地址的值。例如：

    ```c
    int x = 10;  // Declare an integer variable and initialize it with 10
    int *ptr = &x;  // Declare a pointer variable and initialize it with the address of x
    printf("Value of x: %d\n", x);  // Print the value of x
    printf("Address of x: %p\n", &x);  // Print the address of x
    printf("Value of ptr: %p\n", ptr);  // Print the value of ptr (address of x)
    printf("Value pointed by ptr: %d\n", *ptr);  // Print the value at the address pointed by ptr (value of x)
    ptr = &y;  // Change ptr to point to y
    printf("Value of ptr after assignment: %p\n", ptr);  // Print the new value of ptr (address of y)
    ```

    这里使用了指针变量`ptr`来访问和修改变量`x`的值，同时也打印了变量的值和地址。在改变`ptr`的值时，它现在指向了变量`y`。

## 字符串和字符串函数

在C语言中，有一些函数可以用于处理字符串，这些函数被称为字符串函数。字符串函数定义在`<string.h>`头文件中，它们提供了对字符串进行各种操作的功能，如复制、比较、连接、分割、查找等。

以下是一些常用的C语言字符串函数：

1. **strcpy()**: 这个函数用于复制字符串。它接收两个参数，一个目标字符数组和一个源字符数组。它将源字符数组的内容复制到目标字符数组中。

    ```c
    #include <string.h>
    char src[] = "Hello, World!";
    char dest[50];
    strcpy(dest, src);
    ```

2. **strcat()**: 这个函数用于连接两个字符串。它接收两个参数，一个目标字符数组和一个源字符数组。它将源字符数组的内容附加到目标字符数组的末尾。

    ```c
    #include <string.h>
    char dest[50] = "Hello, ";
    char src[] = "World!";
    strcat(dest, src);
    ```

3. **strcmp()**: 这个函数用于比较两个字符串。它接收两个参数，两个字符数组。如果两个字符串相同，它返回0，如果第一个字符串在字典顺序上小于第二个，它返回一个负数，否则返回一个正数。

    ```c
    #include <string.h>
    char str1[] = "Hello, World!";
    char str2[] = "Hello, World!";
    int result = strcmp(str1, str2);
    ```

4. **strlen()**: 这个函数用于获取一个字符串的长度。它接收一个参数，一个字符数组。它返回该数组中第一个空字符'\0'的位置。

    ```c
    #include <string.h>
    char str[] = "Hello, World!";
    int len = strlen(str);
    ```

5. **strstr()**: 这个函数用于在一个字符串中查找另一个字符串。它接收两个参数，一个主字符数组和一个查找字符数组。它返回第一个匹配项的地址，如果没有找到匹配项，则返回NULL。

    ```c
    #include <string.h>
    char str[] = "Hello, World!";
    char find[] = "World";
    char* result = strstr(str, find);
    ```

6. **strncpy()**: 这个函数用于复制指定长度的字符串。它接收三个参数，一个目标字符数组，一个源字符数组和一个小于源字符串长度的正整数n。它复制源字符数组的前n个字符到目标字符数组中。
7. **strtok()**: 这个函数用于将字符串分割为一系列的子串。它接收两个参数，一个要分割的字符数组和一个分隔符字符数组。它返回指向每个子串的指针，如果没有更多的子串，则返回NULL。

请注意，大多数这些字符串函数都是对字符串进行操作，而且都没有检查目标缓冲区的大小。因此，在使用这些函数时，必须确保目标缓冲区有足够的空间来存储结果，否则可能会导致缓冲区溢出和其他相关的问题。

## 作用域、存储类别、链接和内存管理

### 作用域

在C语言中，作用域（Scope）是指变量的可见性和生命周期的区域。变量的作用域决定了它在哪里可以被访问和使用。作用域通常分为以下几种类型：

1. 局部作用域（Local Scope）：局部作用域也称为函数作用域，它是指在函数内部定义的变量和表达式的可见性。在函数内部定义的变量只有在函数内部才能被访问，一旦离开函数的作用域，这些变量就会消失并且不可访问。
2. 全局作用域（Global Scope）：全局作用域也称为程序作用域，它是指在程序中所有函数之外定义的变量和表达式的可见性。在全局作用域下定义的变量可以被程序中的任何函数访问。
3. 静态作用域（Static Scope）：静态作用域也称为文件作用域，它是指在文件内部定义的变量和表达式的可见性。在静态作用域下定义的变量只在该文件内部可见，其他文件无法访问这些变量。
4. 动态作用域（Dynamic Scope）：动态作用域也称为堆栈作用域，它是指在函数调用时动态分配内存空间来存储变量，当函数返回时，这些变量的内存空间将被释放。因此，动态作用域也称为自动作用域。在动态作用域下定义的变量只在当前函数内部可见，一旦离开该函数的作用域，这些变量就会被销毁。

在C语言中，变量的生命周期通常与它们的作用域相关联。局部变量和函数参数的生命周期通常是在函数被调用时开始，在函数返回时结束。全局变量和静态变量的生命周期通常是在程序开始运行时开始，在程序结束时结束。

以下是一个演示C语言中不同作用域的示例程序：

```c
#include <stdio.h>

// 在全局作用域中定义一个全局变量
int global_variable = 10;

// 在函数原型作用域中声明一个函数
void function_prototype(int parameter);

// 在函数作用域中定义一个函数
void function_definition() {
    // 在函数作用域中定义一个局部变量
    int local_variable = 20;

    // 调用函数原型作用域中的函数
    function_prototype(local_variable);

    // 在函数作用域中访问全局变量
    printf("Global variable value: %d\n", global_variable);
}

// 在函数原型作用域中定义一个函数
void function_prototype(int parameter) {
    // 在函数原型作用域中定义一个局部变量
    int temporary = parameter * 2;

    // 在函数原型作用域中访问全局变量
    printf("Global variable value from function prototype: %d\n", global_variable);

    // 在函数原型作用域中访问临时变量
    printf("Temporary value: %d\n", temporary);
}

int main() {
    // 在主函数作用域中调用函数定义
    function_definition();

    // 在主函数作用域中访问全局变量
    printf("Global variable value from main function: %d\n", global_variable);

    return 0;
}
```

输出结果：

```txt
Global variable value from function prototype: 10
Temporary value: 40
Global variable value: 10
Global variable value from main function: 10
```

在上述示例程序中，我们演示了C语言中的不同作用域。首先，在全局作用域中定义了一个全局变量 `global_variable`，它的生命周期贯穿整个程序。接着，在函数原型作用域中声明了一个函数 `function_prototype`，然后在函数作用域中定义了一个函数 `function_definition`。在 `function_definition` 中，我们定义了一个局部变量 `local_variable`，并且调用了 `function_prototype` 函数。在 `function_prototype` 中，我们定义了一个临时变量 `temporary`，并且访问了全局变量。最后，在主函数作用域中，我们调用了 `function_definition` 函数，并且访问了全局变量。

### 存储类别

在C语言中，存储类别是指为变量或函数定义的存储期限和可见性。C语言中的存储类别主要包括以下几种：

1. **自动存储类别（Automatic Storage Class）**：这种类型的变量在函数被调用时自动创建，并在函数返回时销毁。它们通常在函数内部定义，并且只能在函数内部访问。这类变量通常用于存储短期信息，不需要在函数之间共享。

    ```c
    void func() {
        int x = 10; // 自动存储类别的变量
        // ...
    }
    ```

2. **静态存储类别（Static Storage Class）**：这种类型的变量在程序运行期间一直存在，而不仅仅是在函数调用时。它们可以在函数内部或外部定义，可以在函数之间共享。静态变量在程序的生命周期内只初始化一次。

    ```c
    int y = 20; // 静态存储类别的变量

    void func() {
        // ...
    }
    ```

3. **外部存储类别（External Storage Class）**：这种类型的变量具有与静态变量相同的生命周期，但它们只能通过extern声明在文件之间共享。通常，一个源文件中的函数会定义外部变量，然后在其他源文件中使用extern关键字引用它。

    ```c
    // file1.c
    int z = 30; // 外部存储类别的变量

    // file2.c
    extern int z; // 在另一个文件中引用外部变量
    ```

4. **动态存储类别（Dynamic Storage Class）**：这种类型的变量是通过malloc、calloc或realloc等函数动态分配内存的。它们在程序运行时可以分配和释放，通常用于实现动态数据结构，如动态数组或链表。

    ```c
    int* ptr = malloc(int); // 动态存储类别的变量
    ```

请注意，C语言中的函数存储类别默认为自动存储类别，如果要将其更改为静态或外部存储类别，需要使用static或extern关键字显式声明。

### 链接

在C语言中，"链接"通常是指将多个编译后的目标文件组合在一起，生成一个可执行文件的过程。

C语言程序通常由多个源文件组成，每个源文件编译后都会生成一个目标文件（也称为对象文件）。这些目标文件不能直接运行，因为它们只是程序的各个部分，缺少执行程序所需的关键部分（例如主函数）。

链接器（linker）是一个程序，它将一个或多个目标文件和所需的库文件组合在一起，生成一个可执行文件。链接器的主要任务是：

1. 解决目标文件之间的相互引用关系。例如，在一个目标文件中，你可能会调用另一个目标文件中的函数或访问其定义的变量。链接器需要将这些引用链接到正确的函数或变量定义上。
2. 将所需的库函数和全局变量链接到程序中。例如，你可能使用了标准库中的函数，这些函数在编译时并没有提供，而是在链接时由链接器从库文件中找到并链接到程序中。

在Unix或Linux系统中，你可以使用gcc或g++等工具进行链接操作。例如：

```bash
gcc -o executable_name source_file.c
```

这条命令会将`source_file.c`编译并链接成一个名为`executable_name`的可执行文件。

在Windows系统中，你可以使用Microsoft的Visual Studio开发环境进行链接操作，或者使用cl.exe编译器进行链接操作。例如：

```bash
cl /EHsc source_file.c /Fe:executable_name.exe
```

这条命令会将`source_file.c`编译并链接成一个名为`executable_name.exe`的可执行文件。

### 内存管理

C语言中的内存管理是由程序员自己负责的，可以通过一些函数和机制来进行操作。以下是一些C语言中的内存管理相关的知识点：

1. 内存分配函数

    C语言提供了几个函数用于在运行时分配内存，其中包括：

    * malloc(size_t size)：该函数返回一个指向大小为size的足够空间的指针，这些空间是用系统内存中的未使用区域动态分配的。
    * calloc(size_t nmemb, size_t size)：该函数返回一个指向大小为nmemb * size的足够空间的指针，这些空间是用系统内存中的未使用区域动态分配的，并且被初始化为0。
    * realloc(void* ptr, size_t size)：该函数返回一个指向大小为size的足够空间的指针，其中初始化为NULL的空间将被分配并返回。如果ptr指向的内存在reallloc函数中不够用，系统会重新分配一块足够大的内存区域并返回新的指针；如果ptr指向的内存在reallloc函数中足够用，那么直接返回该指针即可。
    * free(void* ptr)：该函数释放之前通过malloc、calloc或realloc分配的内存块。被释放的内存块会被返回到系统内存中，以便再次使用。

2. 内存地址操作

    C语言还提供了一些用于操作内存地址的函数，包括：

    * &运算符：该运算符可以获取变量的地址。例如：int a = 10; int* ptr = &a;，此时ptr指向a的地址。
    * *运算符：该运算符可以获取指针指向变量的值。例如：int a = 10; int* ptr = &a;，此时*ptr的值等于a的值，即10。
    * **运算符：该运算符可以获取指针指向指针的变量值。例如：int** ptr1 = &ptr;，此时**ptr1的值等于ptr的值，即a的地址。

3. 内存管理注意事项

    在进行内存管理时，需要注意以下几点：

    * 分配内存后一定要记得释放，否则会导致内存泄漏；
    * 不要去释放未经分配的内存，否则会导致未定义行为；
    * 在释放内存后，不要再去使用该内存，否则会导致未定义行为；
    * malloc和calloc分配的内存块在未使用前都是未初始化的，可以使用memset等函数进行初始化。

下面是一个使用C语言进行内存管理的演示：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int num = 10;
    int *arr = (int*)malloc(sizeof(int) * num);
    if(NULL == arr) {
        perror("malloc::arr");
        return -1;
    }
    
    for(int i = 0; i < num; i++) {
        *(arr + i) = i;
    }
    
    for(int i = 0; i < num; i++) {
        printf("%d ", *(arr + i));
    }
    
    free(arr);
    arr = NULL;
    
    return 0;
}
```

在这个演示中，我们首先使用malloc函数分配了一个大小为10个int类型的动态数组，然后通过指针arr访问这个数组的每个元素，将它们初始化为0到9的整数。接着，我们使用for循环遍历这个数组，将每个元素的值输出到屏幕上。最后，我们使用free函数释放了这个数组所占用的内存，并将arr指针置为NULL。

## 文件输入输出，标准 I/O 通信

## 结构体、联合、枚举、函数指针

## 位操作，二进制数位和字节，按位运算

## C预处理器宏定义、内联函数和C库

## 高级数据结构，队列链表二叉查找树
