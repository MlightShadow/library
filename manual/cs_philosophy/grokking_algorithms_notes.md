# 算法图解

## 二分查找

仅当列表为有序的时候, 二分查找才有用.

## 大O表示法

常见的5种
O(log n) 对数时间
O(n) 线性时间
O(n * log n)
O(n^2)
O(n!)

算法的速度讨论的并非时间, 而操作数的增速

## 数组和链表

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 插入 | O(n) | O(1) |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |

## 选择排序

O(n^2)
速度较慢, 通过2次循环遍历完成排序

## 递归与调用栈

使用递归时调用栈需要消耗大量内存, 解决办法: 1.使用循环;2.使用尾递归(但不是所有语言都支持尾递归);

## D&C(分而治之)

* 找出简单的基线条件
* 确定如何缩小问题的规模, 使其符合基线条件

## 快速排序

通过从空数组与一个元素的数组直接返回, 作为基线条件
将更多元素的数组通过基准值分为两个子数组, 从而不断进行排序

## 散列表

散列表的实现使用数组与链表相结合, 散列表包含元素总数/数组位置总数==装填因子
经验认为当装填因子大于0.7时, 就需要调整散列表的长度

## 广度优先搜索

解决最短路径问题, 利用队列, 按照邻居顺序遍历节点, 适合非加权图, 有环时注意判断是否已遍历, 否则容易死循环

## 狄克斯特拉算法

适合有向加权无环图
关键理念: 找出图中最小(大)权节点, 并确保没有更小(更大)的路径

## 负边权

边的加权为负
狄克斯特拉算法无法处理, 需要使用 贝尔曼-福德算法(Bellman-Ford algorithm)

> 书上指出的这个例子正好是通向同一个节点包含负边权, 但是如果但是两个指向不同节点的边存在一个负边权或者都是负边权, 狄克斯特拉算法似乎依然有效

## 贪婪算法

局部最优解
简单易行, 如果不强求全局最优, 大部分情况下都会比较接近最优解或者就是最优解
